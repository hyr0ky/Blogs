## 审计的注意点
>命令执行漏洞是指应用有时需要调用一些执行系统命令的函数，如果系统命令代码未对用户可控参数做过滤，则当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击。首先我们了解一下命令连接符的使用。

### 命令拼接符

```java
Windows与Linux均支持：
cmd1 | cmd2 只输出cmd2的结果，但两个命令均会执行
cmd1 || cmd2 只有当cmd1执行失败后，cmd2才被执行
cmd1 & cmd2 先执行cmd1，不管是否成功，都会执行cmd2
cmd1 && cmd2 先执行cmd1，cmd1执行成功后才执行cmd2，否则不执行cmd2


Linux单独支持:
cmd1;cmd2 依次执行命令
```


### 需关注的函数
```java
Runtime.getRuntime().exec()
Process
UNIXProcess
ProcessImpl
ProcessBuilder.start()
GroovyShell.evaluate()
```

## Runtime.getRuntime().exec()
>java.lang.Runtime 公共类中的 exec()方法可以执行系统命令，其中需要关注是否为cmd /c，在不使用cmd /c的时候，只能执行单个命令，无法使用|和&进行连接执行多个命令，当使用|和&连接时会将其当成一个整体命令执行。而使用cmd /c就可以执行复杂命令。


![](media/640%2015.webp)  
上述代码中，userinput模拟用户输入，command为执行的命令，尝试执行ipconfig && dir。

![](media/640%2016.webp)  
执行成功。但是在审计的时候除了正射调用，也可能存在反射调用exec进行命令执行
![](media/640%2017.webp)  
上述代码就展示了反射如何调用java.lang.Runtime 公共类中的 exec()方法，尝试进行命令执行。
![](media/640%2018.webp)  
探索一下如何调用的，首先进入exec方法。
![](media/640%2019.webp)  

再次进入下面return的方法。
![](media/640%2020.webp)  
![](media/640-1%201.webp)  
可以看到最终调用的是ProcessBuilder方法，那么下一个就是processbuilder的命令执行。
## ProcessBuilder.start()
>ProcessBuilder.start() 方法的主要作用就是启动一个新的操作系统进程。这个进程独立于当前的 Java 应用程序，有自己的输入、输出和错误流。通过这个方法，你可以执行外部命令或脚本，就像在命令行中手动执行一样。需要注意的是，在processbuilder中传入的cmd只能以字符串数组的形式来传递命令和参数，否则会出现报错。
![](media/640%2021.webp)  

测试命令执行。
![](media/640%2022.webp)  
执行成功。我们再跟进一下processbuilder.start()查看其调用，跟进start，可以看到最终执行是ProcessImpl.start()这里ProcessImpl更为底层。Runtime和ProcessBuilder执行命令实际上也是调用了ProcessImpl这个类。
![](media/640%2023.webp)  
代码示例如图所示，如果未经过过滤则会直接导致命令执行。
![](media/640%2024.webp)  
