## 基础结构
```java
/**
 * @name 规则名称         --> 类似Java的类注释
 * @kind 问题类型         --> 类似定义类用途
 */
import java               --> 类似Java的import

/* 类定义（声明式规则） */
class MyRule extends TaintTracking::Configuration {
  MyRule() { this = "标识名" }  --> 构造函数
  
  /* 定义漏洞入口（类似Spring Controller参数） */
  override predicate isSource(DataFlow::Node source) {
    exists(Parameter p |      --> 存在性检查
      p.getCallable().getDeclaringType()
        .hasAnnotation("org.springframework.stereotype.Controller") 
      &&
      source.asParameter() = p
    )
  }
  
  /* 定义漏洞出口（类似executeQuery方法） */
  override predicate isSink(DataFlow::Node sink) {
    exists(MethodAccess ma |  --> 存在方法调用
      ma.getMethod().getName() = "executeQuery" 
      &&
      ma.getMethod().getDeclaringType()
        .hasQualifiedName("java.sql", "Statement")
      &&
      sink.asExpr() = ma.getArgument(0)
    )
  }
}

/* 执行查询（类似main方法） */
from MyRule config, DataFlow::PathNode source, DataFlow::PathNode sink
where config.hasFlowPath(source, sink)  --> 存在污染路径
select sink.getNode(), source, sink, "漏洞描述"
```



## 核心语法拆解

### 类定义（声明式规则）

```codeql
class MyRule extends TaintTracking::Configuration {
  // 定义污染跟踪规则
  // 必须继承 TaintTracking::Configuration
}
```

### 存在量词（exists）
```codeql
exists(变量声明 | 条件表达式)
```

```java
// 类似Java的：
for (Parameter p : allParameters) {
  if (p.getDeclaringType().isController()) {
    // 存在符合条件的参数
  }
}
``` 
### 方法调用识别

```codeql
ma.getMethod().getName() = "executeQuery"
```

```java
// 类似反射获取方法名：
method.getName().equals("executeQuery")
```

### 类型检查

```codeql
.hasQualifiedName("java.sql", "Statement")
```

```java
// 类似Java的：
clazz.getPackage().getName().equals("java.sql") 
&& clazz.getSimpleName().equals("Statement")
```

###  数据流节点
```codeql
DataFlow::Node       --> 表示数据流中的任意节点
DataFlow::PathNode   --> 带路径信息的节点
```

## 关键谓词详解

###  isSource（污染源）
```codeql
override predicate isSource(Node source) {
  // 识别Spring Controller参数
  exists(Parameter p |
    p.getCallable().getDeclaringType()
      .hasAnnotation("org.springframework.stereotype.Controller") 
    &&
    source.asParameter() = p
  )
}
```

### isSink（污染终点）
```codeql
override predicate isSink(Node sink) {
  // 识别Statement.executeQuery的第一个参数
  exists(MethodAccess ma |
    ma.getMethod().getName() = "executeQuery" 
    &&
    ma.getMethod().getDeclaringType()
      .hasQualifiedName("java.sql", "Statement")
    &&
    sink.asExpr() = ma.getArgument(0)
  )
}
```

###  附加污染步骤

```codeql
override predicate isAdditionalTaintStep(Node n1, Node n2) {
  // 处理字符串拼接
  exists(AddExpr add | 
    add.getOperand() = n1.asExpr() 
    && 
    add = n2.asExpr()
  )
}
```

## 数据流跟踪原理
```codeql
source(污染源) 
-> 变量传递 
-> 字符串拼接 
-> SQL语句构造 
-> sink(执行点)
```

## 调试技巧

###  查看中间变量

```codeql
from AddExpr add
select add, "发现字符串拼接操作"
```

### 跟踪具体参数
```codeql
from Parameter p
where p.getName() = "userId"
select p, "跟踪特定参数"
```

### 检查注解
```codeql
from Annotation a
where a.getType().hasQualifiedName("org.springframework.stereotype", "Controller")
select a, "找到Controller注解"
```

## 对比学习表

| CodeQL 结构            | Java 类比      | 作用说明          |
| -------------------- | ------------ | ------------- |
| `exists()`           | for循环 + if判断 | 存在性检查         |
| `getMethod()`        | 反射获取Method对象 | 方法调用识别        |
| `hasQualifiedName()` | 包名+类名检查      | 精确类型匹配        |
| `DataFlow::Node`     | 数据流节点对象      | 表示变量/表达式的数据流动 |
| `override predicate` | 接口方法实现       | 定义自定义规则       |
