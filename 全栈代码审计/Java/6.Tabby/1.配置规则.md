- https://cina666.github.io/2025/03/24/%E5%B7%A5%E5%85%B7tabby%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/#%E6%B3%A8%E6%84%8F%E7%82%B9
- https://www.yuque.com/wh1t3p1g/tp0c1t/mgihyvp3vgscgt63#db3ee5e9
## 配置文件

### 常见配置场景

#### 利用链挖掘
1. 挖掘运行环境的 JDK 里面的利用链
```java
# enables
tabby.build.isJDKOnly                     = true
tabby.build.mode                          = gadget
```
2. 挖掘指定Jdk版本里面的利用链子
```java
tabby.build.useSettingJRE                 = true
tabby.build.isJRE9Module                  = true
tabby.build.javaHome                      = /Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home
# enables
tabby.build.isJDKOnly                     = true
tabby.build.mode                          = gadget
```
3. 挖掘 target 目录文件的利用链
```java
tabby.build.isJDKProcess                  = true
# targets to analyse
tabby.build.target                        = target
tabby.build.libraries                     = libs
tabby.build.mode                          = gadget
```
4. 常见漏洞挖掘
```java
# targets to analyse
tabby.build.target                        = target
tabby.build.libraries                     = libs
tabby.build.mode                          = web
```
5. 快速挖掘Web项目
```java
# targets to analyse
tabby.build.target                        = target
tabby.build.libraries                     = libs
tabby.build.mode                          = web
tabby.build.onDemandDrive                 = true
```
### 配置文件详细介绍

#### 日常使用的参数
- Tabby： `config/settings.properties`  
```java
# targets to analyse
tabby.build.target                        = cases/java-sec-code-1.0.0.jar
tabby.build.libraries                     = libs
tabby.build.mode                          = web
#tabby.build.mode                          = gadget
tabby.output.directory                    = ./output/dev
tabby.build.rules.directory               = ./rules
tabby.build.thread.size                   = max
```

- `tabby.build.target`: 待分析的文件名或文件夹
- `tabby.build.libraries`：部分需要增加的常见依赖目录，比如 javax.servlet-3.0.0.v201103241009.jar
- `tabby.build.mode`：分析模式，gadget模式会分析所有遍历到的文件；web模式会根据common-jars.json文件剔除部分常见依赖后进行分析。
- `tabby.output.directory`： 代码属性图csv文件输出的目录
- `tabby.build.rules.directory`：tabby的规则目录
- `tabby.build.thread.size`：分析所需的线程数，数值类型，默认为max，根据机器性能自动选择数量

其余参数基本不需要修改，尝试不同的场景时搭配组合即可。



#### 指定Jdk依赖用于分析
```java
# settings for jre environments
tabby.build.useSettingJRE                 = false
tabby.build.isJRE9Module                  = false
tabby.build.javaHome                      = /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home
```

- 默认情况下，分析项目时用到的JDK依赖都是17版本。上述规则可以用来配置指定的JDK版本
- 默认情况下，`tabby.build.useSettingJRE`为`false`，使用当前运行Jar的JDK版本。如无特殊需求，可以保持该配置为`false`。当需要指定特定 JDK 版本时，`tabby.build.useSettingJRE`改为`true`。
- 同时配置好`tabby.build.javaHome`，并根据指定的JDK版本是否大于9，来配置`tabby.build.isJRE9Module`。
- 对于`tabby.build.useSettingJRE`为`true`的情况，第一次运行时会将目标javaHome下的jdk依赖都复制到`jre_libs`目录，这个过程会花费一些时间，请耐心等待。后续的运行将会直接载入`jre_libs`目录下的JDK作为分析的依赖。
>注意：如果修改了`tabby.build.javaHome`内容，则需要同时删除`jre_libs`目录，不然修改将不会生效。

#### 配置Jdk依赖是否参与分析

```java
# jdk settings
tabby.build.isJDKProcess                  = false # 分析过程是否加入基础的2个jdk依赖
tabby.build.withAllJDK                    = false # 分析过程是否加入全量的jdk依赖
tabby.build.isJDKOnly                     = false # 分析过程是否仅分析jdk依赖，不会去分析target目录下的文件
```

上述配置用于配置分析过程中是否需要将JDK依赖一起进行分析。

`tabby.build.isJDKProcess=true`时，将会加入几个JDK的基础依赖一起分析。
`tabby.build.withAllJDK=true`时，将会加入所有的JDK依赖一起分析。
`tabby.build.isJDKOnly=true`时，将只分析所有JDK依赖，前面配置的target将不会被分析。

#### 配置是否分析所有函数
```java
tabby.build.analysis.everything           = true
```
正常情况下，对于静态函数调用且入参为空的情况，该函数的分析结果不会影响当前函数的分析，所以此类函数的分析是可以被忽略的。但可能也存在需要此类函数的情况，为此，参数`tabby.build.analysis.everything`将被用于开启或关闭对上述类型函数的分析。当设置为`true`时，将分析所有的函数，反之，则忽略上述函数的情况。不过设置为`true`的情况，会增加分析的时间。在使用时，可根据自己的情况来设置。

#### 特殊的分析场景

```java
tabby.build.onDemandDrive                 = false
```
在分析Web项目的时候，有个痛点就是分析了很多无用的函数，大部分函数并不能从endpoint入口访问到。

为此，为了能进一步提升分析速度，开放了`tabby.build.onDemandDrive`按需分析的模式。

当配置为`true`时，将仅从source函数开始进行分析（source的定义见tags.json文件）。非source函数所经过的函数将不会被分析，极大地提升分析速度。


## 规则文件

Tabby v2.0 一共有 6 个规则文件，其主要作用是在分析过程前或中精确打标对应函数。

1. tags.json，用于打标 source 函数
2. sinks.json，用于打标 sink 函数
3. system.json，用于人工提供精确的污点结果来引导分析更加准确
4. xmlRules.json，用于识别 xml 文件中的相关函数配置，如 mybaitis sql语句的提取，需要配置tags.json文件一起使用
5. commonJars.json，用于加速分析，忽略被匹配到的三方依赖的分析
6. basicClasses.json，补充soot的基础类型，基本无需关系该规则文件

### 函数识别
#### tags.json
tags.json规则文件用于分析前定位到特定的函数，并给该函数打上对应的标记。

下面是一条识别常见Web项目注解端点的规则，让我们来看下几个常见key的value定义。
```json
{
  "name": "web-tags",
  "type": "annotation",
  "value": "web",
  "annotations": [
    "%Mapping",
    "javax.ws.rs.%",
    "javax.jws.%"
  ],
  "classes": [],
  "methods": [],
  "whitelist": []
}
```

- `name`用于标识当前规则名，没有特殊限制
- `type`用于描述当前规则是对哪个位置进行生效的，共有 3 种，并分别对应下面3个key值
	- `annotation`注解类型
	- `class`类名类型
	- `method`函数名类型
	- 此外，还支持并操作，比如`class&method`将同时检查类名和函数名，仅当两者都符合的情况下才会打标
- `value`用于填充`MethodReference`的`type`参数，当前可填写`web`、`netty`、`dao`
- `annotations``classes``methods`用于匹配对应的注解内容、类名、函数名，支持前后向模糊匹配，使用`%`即可，可参考开源的tags.json内容
- `whitelist`用于加白虽然匹配上前面内容但是非对应类型函数的情况，仅可填写对应的类名

#### xmlRules.json
除了上述的使用方式，还可以配合`xmlRules.json`的规则配置来动态生成类名或函数名。

比如存在数据库查询接口的需求，但是此类接口并不能用单一简单的规则识别出来，可能需要解析xml的方式才能正常识别。为此，tabby v2.0 开放了解析xml的方式来获取此类数据。

首先，在tags.json文件中创建一个匹配参数均为空的规则
```json
{
  "name": "mybatis-dto",
  "type": "class&method",
  "value": "dao",
  "annotations": [],
  "classes": [],
  "methods": [],
  "whitelist": []
}
```
其次，在xmlRules.json文件中创建相同name的规则，其中classes和methods采用XPath语法来识别对应的xml内容。
```json
{
  "name": "mybatis-dto",
  "classes": [
    "//mapper/@namespace",
    "//mapper/@class"
  ],
  "methods": [
    "//mapper/insert/@id",
    "//mapper/select/@id",
    "//mapper/update/@id",
    "//mapper/delete/@id"
  ]
}
```
经过这种方式，在xml解析完成后，会将`mybatis-dto`这个tags规则的classes、methods内容进行动态填充。

#### sinks.json、system.json

```json
{"name": "java.lang.Runtime","rules": [
    {
      "function": "exec",
      "type": "sink",
      "vul": "EXEC",
      "actions": {"return<s>": ["param-0"]},
      "polluted": [[0]],
      "max": 0
    },
]},
```
- `name`用于标识类名
- `rules`用于标识一系列的函数
	- `function`用于描述函数名，可直接写函数名，比如`exec`，也可以写带参数的sub_signature的格式，如`java.lang.Process exec(java.lang.String[])`。
	- `type`用于描述打标的类型，当前支持`sink`、`know`、`ignore`
		- `sink`表示具备危险功能的函数
		- `know`表示由人工提供污点缓存的函数，用于人工提升分析效果
		- `ignore`表示不分析此类规则所代表的函数
	- `vul`用于描述sink函数的类型，仅用于`type=sink`的情况
	- `actions`用于配置当前函数的污点缓存，规则可参考kcon ppt里的说明
	- `polluted`用于描述sink函数的哪些位置是可控的情况下，才能造成危害，如例子中表示第一个参数可控的情况下，该sink函数才是具有危害的，相关定义也可参考kcon ppt里的说明
	- `max`用于配合`function`中模糊的函数配置，比如`function=exec`且`max=1`，表示仅当函数名为exec且参数数量>=1的函数才符合当前规则。如果希望匹配所有`exec`函数，则配置`max=-1`即可

#### commonJars.json
> 由于tabby默认是以全量分析的方式来分析整个项目，但是很多情况下三方依赖分不分析都不影响项目的分析。针对这种情况，忽略掉该三方依赖的分析不仅可以加快分析速度，也可以加快后续的cypher查询速度。
```json
[
  "commons-",
]
```
commonJars.json文件的规则仅支持匹配依赖的前向名字，比如`commons-`表示以该字符串开头的所有jar都会被忽略掉。

## 代码属性图


## Tabby-Path-Finder路径检索函数





