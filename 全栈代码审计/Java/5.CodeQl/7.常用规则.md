
## SQL

### Jdbc
- Statements / PreparedStatements / SpringJdbcTemplate 漏洞
```Java
/**
 * @name Statements / PreparedStatements / SpringJdbcTemplate vulnerable to SQL injection
 * @description Detects potential SQL injection vulnerabilities in JDBC by tracking tainted data from user input to SQL command execution.
 * @kind path-problem
 * @problem.severity error
 * @tags security
 *       external/cwe/cwe-089
 *       external/cwe/cwe-079
 * @precision high
 * @id java-jdbc-injection
 * @cwe-ids CWE-089, CWE-079
 */

import java
import semmle.code.java.dataflow.DataFlow
import semmle.code.java.dataflow.TaintTracking
import semmle.code.java.dataflow.FlowSources

class SimpleType extends Type {
  SimpleType() {
    this instanceof PrimitiveType or
    this instanceof BoxedType or
    this instanceof NumberType or
    this.(RefType).hasQualifiedName("java.util", "UUID") or
    this.(RefType).getASourceSupertype*().hasQualifiedName("java.util", "Date") or
    this.(RefType).hasQualifiedName("java.util", "Calendar") or
    this.(RefType).hasQualifiedName("java.util", "BitSet") or
    this.(RefType).getASourceSupertype*().hasQualifiedName("java.time.temporal", "TemporalAmount") or
    this.(RefType).getASourceSupertype*().hasQualifiedName("java.time.temporal", "TemporalAccessor") or
    this instanceof EnumType
  }
}

class StatementSql extends Expr {
  StatementSql() {
    exists(MethodCall mc |
      mc.getMethod()
          .getDeclaringType()
          .getASourceSupertype*()
          .hasQualifiedName("java.sql", "Statement") and
      (
        mc.getMethod().getName().matches("execute%") or
        mc.getMethod().getName() = "addBatch" // 添加批处理语句
      ) and
      this = mc.getArgument(0)
    )
  }
}

class PreparedStatementSql extends Expr {
  PreparedStatementSql() {
    exists(MethodCall mc |
      mc.getMethod()
          .getDeclaringType()
          .getASourceSupertype*()
          .hasQualifiedName("java.sql", "Connection") and
      mc.getMethod().getName() = "prepareStatement" and
      this = mc.getArgument(0)
    )
  }
}

class SpringJdbcTemplateSql extends Expr {
  SpringJdbcTemplateSql() {
    exists(MethodCall mc |
      mc.getMethod()
          .getDeclaringType()
          .getASourceSupertype*()
          .hasQualifiedName("org.springframework.jdbc.core", "JdbcTemplate") and
      (
        mc.getMethod().getName().matches("query%") or
        mc.getMethod().getName() = "update" or
        mc.getMethod().getName() = "execute" or
        mc.getMethod().getName() = "batchUpdate"
      ) and
      this = mc.getArgument(0)
    )
  }
}

module JDBC implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource }

  predicate isSink(DataFlow::Node sink) {
    sink.asExpr() instanceof StatementSql
    or
    sink.asExpr() instanceof PreparedStatementSql
    or
    sink.asExpr() instanceof SpringJdbcTemplateSql
  }

  predicate isBarrier(DataFlow::Node barrier) {
    // 处理掉基本类型和包装类型
    barrier.getType() instanceof SimpleType
    or
    barrier.getType().(ParameterizedType).getATypeArgument() instanceof SimpleType 
    // // 处理掉SetString方法 （预编译SQL语句时，使用占位符?来代替参数，然后通过setString等方法设置参数值，从而避免SQL注入攻击）
    // exists(MethodCall mc |
    //   mc.getMethod().hasName("setString") and
    //   mc.getMethod().getDeclaringType().hasQualifiedName("java.sql", "PreparedStatement") and
    //   barrier.asExpr() = mc
    // )

    // 不需要处理setstring方法，无漏洞的时候是先PreparedStatement 再SetString 所以污点不会传入SetString
  }
}

module Flow = TaintTracking::Global<JDBC>;

import Flow::PathGraph

from Flow::PathNode source, Flow::PathNode sink
where Flow::flowPath(source, sink)
select sink.getNode(), source,sink,
       "污染数据 从 $@ 到达Sql执行节点 $@ 处，可能存在SQL注入漏洞",
       source.getNode(), source.toString(),
       sink.getNode(), sink.toString()

```

- 