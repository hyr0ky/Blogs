## Codeql基本流程
1. 定义source谓词
2. 定义sink谓词
3. t补全，引入数据流 ，补全代码
4. [3.全局污点分析(⭐)](2.CodeQl语法.md#3.全局污点分析(⭐))

```java
import java
import semmle.code.java.dataflow.DataFlow
import semmle.code.java.dataflow.TaintTracking


module JdbcTaintConfig implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    (source instanceof RemoteFlowSource)   // 确保是远程输入源
	and 
	exists(Method method |                 // 额外限制必须是 Controller 方法的参数
		method instanceof AllControllerMethod and
		source.asParameter() = method.getAParameter() 
			// 将数据流节点转换为参数对象
			// method.getAParameter()获取方法的所有参数
		)
  }

  predicate isSink(DataFlow::Node sink) {
    exists(Expr arg, MethodCall call |
      sink.asExpr() = arg and
      isExecuteMethod(call) and  // 直接调用全局谓词
      arg = call.getArgument(0)
    )
  }
}

/************************ 执行部分 ************************/
module JdbcFlow = TaintTracking::Global<JdbcTaintConfig>;
import JdbcFlow::PathGraph

from JdbcFlow::PathNode source, JdbcFlow::PathNode sink
where JdbcFlow::flowPath(source, sink)
select sink.getNode(), source, sink, "用户输入 $@ 流向SQL执行点",
 source.getNode(), "来自Controller参数"


```




## Apache Struts 不安全反序列化漏洞分析

- https://github.blog/security/vulnerability-research/apache-dubbo-all-roads-lead-to-rce/
- CVE-2017-9805

### 1.查找Xml规范化（sink）

>[XStream](https://x-stream.github.io/index.html)是一个Java框架，用于将Java对象序列化为Apache Struts使用的XML。它提供了一个方法`XStream.fromXML`来将XML转换为Java对象。默认情况下，不以任何方式验证输入，并且容易受到远程代码执行漏洞的攻击。在本节中，我们将识别代码库中对`fromXML`的调用。

1. 找到程序中所有方法调用
```java
import java

from MethodCall call
select call
```
2. 查询每个方法调用所调用的方法
```java
import java

from MethodCall call, Method method
where method = call.getMethod()
select call,"调用的方法：",method
```
3. 查找程序中对名为`fromXML`的方法的所有调用。
```java
import java

from MethodCall call,Method method
where method = call.getMethod() and method.hasName("fromXML")
select "程序中对名为fromxml的方法的调用：",call


因为现在只使用方法调用，不需要打印方法
import java

from MethoCall Fromxml
wher Fromxml.getMethod().hasName("fromXML")
select "程序中对名为fromxml的方法的调用：",Fromxml
```
4. `XStream.fromXML`方法将第一个参数（即索引`0`处的参数）转换为参数。更新您的查询以报告已验证的参数。
```java
import java

from MethodCall call,Expr arg  // Expr 保存参数表达式
where 
	call.getMethod().getName() = "fromXML" and
	arg = call.getArgument(0) // MethodCall.getArgument(int i) 返回第i个索引处的参数。
select call,arg
```
5. 封装谓词
```java
import java


predicate isXMLDeserialized(Expr arg) {
  exists(MethodCall fromXML |
    fromXml.getMethod().hasName("fromXml") and
    arg = fromXml.getArgument(0)
  )
}

from Expr arg
where isXMLDeserialized(arg)
select arg
```
[`exists`](https://help.semmle.com/QL/ql-handbook/formulas.html#exists)是一种引入具有有限作用域的临时变量的机制。你可以把它们看作是自己的`from`-`where`-`select`。  我们使用它来引入`fromXML`临时变量，类型为`MethodCall`。

### 2.从ContentTypeObject中查找toObject方法的实现（Source）
1. 创建一个名为`ContentTypeHandler`的CodeQL类来查找接口`org.apache.struts2.rest.handler.ContentTypeHandler`
```java
import java

class ContentTypeHandler extends RefType{
	ContentTyperHandler(){
		this.hasQualifiedName("org.apache.struts2.rest.handler","ContentTypeHandler")
		//RefType.hasQualifiedName(string packageName, string className) 来标识具有给定包名和类名的类
	}
}
```
2. 创建一个名为`ContentTypeHandlerToObject`的CodeQL类，用于在直接超类型包括`Method`的类上标识名为`toObject`的`ContentTypeHandler`
```java
import java


class ContentTypeHandler extends RefType{
	ContentTyperHandler(){	
	this.hasQualifiedName("org.apache.struts2.rest.handler","ContentTypeHandler")
		//RefType.hasQualifiedName(string packageName, string className) 来标识具有给定包名和类名的类
	}
}

class ContentTypeHandlerToObject extends Method {
	ContentTypeHandlerToObject(){
		this.getDeclaringType().getASupertype() instanceof ContentTypeHandler 
		// 标识方法的声明类型，使用Method.getDeclaringType()
		// 标识该类型的超类型，RefType.getASuperType()
		and
	    this.hasName("toObject")
	}
}
```
3. toObject方法第一个参数视为不可信的用户输入
```java
import java

class ContentTypeHandler extends RefType{
	ContentTyperHandler(){	
	this.hasQualifiedName("org.apache.struts2.rest.handler","ContentTypeHandler")
		//RefType.hasQualifiedName(string packageName, string className) 来标识具有给定包名和类名的类
	}
}

class ContentTypeHandlerToObject extends Method {
	ContentTypeHandlerToObject(){
		this.getDeclaringType().getASupertype() instanceof ContentTypeHandler 
		// 标识方法的声明类型，使用Method.getDeclaringType()
		// 标识该类型的超类型，RefType.getASuperType()
		and
	    this.hasName("toObject")
	}
}

from ContentTypeHandlerToObject toObjectMethod,Expr arg
where arg = toObjectMethod.getParameter(0)
// Method.getParameter(int index)获取第i个索引参数
select 'toObject方法的第一个参数:' ,arg
```
### 3.不安全的XML文档化

```java
import java
import semmle.code.java.dataflow.DataFlow
import semmle.code.java.dataflow.TaintTracking


class ContentTypeHandler extends RefType{
	ContentTyperHandler(){	
	this.hasQualifiedName("org.apache.struts2.rest.handler","ContentTypeHandler")
		//RefType.hasQualifiedName(string packageName, string className) 来标识具有给定包名和类名的类
	}
}

class ContentTypeHandlerToObject extends Method {
	ContentTypeHandlerToObject(){
		this.getDeclaringType().getASupertype() instanceof ContentTypeHandler 
		// 标识方法的声明类型，使用Method.getDeclaringType()
		// 标识该类型的超类型，RefType.getASuperType()
		and
	    this.hasName("toObject")
	}
}

predicate isXMLDeserialized(Expr arg) {
  exists(MethodCall fromXML |
    fromXML.getMethod().getName() = "fromXML" and
    arg = fromXML.getArgument(0)
  )
}

module XmlTaintConfig implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
	exists(ContentTypeHandlerToObject toObjectMethod |
	 source.asParameter() = toObjectMethod.getParameter(0)
	)
  }

  predicate isSink(DataFlow::Node sink) {
    exists(Expr arg |
      sink.asExpr() = arg and
      isXMLDeserialized(arg)
    )
  }
}

/************************ 执行部分 ************************/
module XmlFlow = TaintTracking::Global<XmlTaintConfig>;
import XmlFlow::PathGraph

from XmlFlow::PathNode source, XmlFlow::PathNode sink
where XmlFlow::flowPath(source, sink)
select "Unsafe XML deserialization",source, "数据源汇入：",sink
```


## Apache Dubbo RCE学习
- https://github.blog/security/vulnerability-research/apache-dubbo-all-roads-lead-to-rce/

