
## AFL架构

```C
					----->  {数据输入} ---------------——插桩--->
{数据生成器}                                       {进程}
					<-反馈-- {路径信息统计/规整} <——传递路径信息——
					
					
数据生成器 ：基于反馈针对性编译

插桩：
void fun() {
    data = input();
    // 插桩点：记录基本块执行
    afl_maybe_log(0x1000);
    
    if (data[0] == "a") {
        // 路径A
        afl_maybe_log(0x2000);  // 记录路径A
        // 执行A路径代码
    } else {
        // 路径B
        afl_maybe_log(0x3000);  // 记录路径B
        // 执行B路径代码
    }
}
```

```mermaid
flowchart TD
    A([数据生成器]) -->|生成测试数据| B[目标进程]
    B --> C{执行程序}
    C -->|路径A| D[记录路径A]
    C -->|路径B| E[记录路径B]
    D --> F[路径信息统计/规整]
    E --> F
    F -->|反馈路径覆盖率| A
    
    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style B fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    style F fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
```

## 覆盖率插桩

### 如何插桩

#### 汇编层
- 与架构相关

- 数据输入后，通过if和else 找路径信息 ----   ELF文件
- 高级语言 --> 汇编 --> bin   
- 在汇编这里， 寻找条件跳转点（JNI ADDR），插入func
![](media/无标题.png)  
#### llvm pass（官方API）
- 与架构无关 

- clang / llvm
- {高级语言} ---clang ---> {IR}  ----LLVM --->{汇编/bin}
- 在IR这里插桩
![](media/无标题-1.png)  
### 桩函数的功能



## forkserver


## afl-fuzz&forkserver交互



## AFL源码相关测试



