- https://github.com/topics/electron-app
- https://github.com/doyensec/awesome-electronjs-hacking


## Electron架构

- Chromium：网页渲染
- Node.js：操作系统API
![](media/Pasted%20image%2020250926005253.png)  

### 主进程

>每个 Electron 应用都有一个单一的主进程，作为应用程序的入口点。 主进程在 Node.js 环境中运行，这意味着它具有 `require` 模块和使用所有 Node.js API 的能力。

![Chrome的多进程架构](media/Pasted%20image%2020250926005528.png)  

### 渲染进程
>渲染进程只能渲染网页

每个 Electron 应用都会为每个打开的 `BrowserWindow` ( 与每个网页嵌入 ) 生成一个单独的渲染器进程。 洽如其名，渲染器负责`渲染网页`内容。 所以实际上，运行于渲染器进程中的代码是须遵照网页标准的 (至少就目前使用的 Chromium 而言是如此) 。


### 预加载脚本

1. 主进程与操作系统交互
2. 渲染进程只能渲染网页
3. 当功能需要操作系统支持时，需要渲染进程 <----> 主进程 进行通信 -----也就是`IPC`功能
4. 渲染进程的通信通常在`预加载`(`preload`)脚本中

预加载（`preload`）脚本包含了那些执行于渲染器进程中，且先于网页内容开始加载的代码 。 这些脚本虽运行于渲染器的环境中，却因能访问 Node.js API 而拥有了更多的权限，当然，为了安全考虑，它的 API 是受限的，主要就是发起 `IPC` 请求或监听，将自定义的API和变量等传递给渲染进程使用

### 实用进程

在 `Electron 22.0.0` 中开始引入 `utility process`，每个Electron应用程序都可以使用主进程生成多个子进程`UtilityProcess API`，实用进程（官方翻译叫效率进程）可用于托管，例如：不受信任的服务， CPU 密集型任务或以前容易崩溃的组件托管在主进程或使用Node.js`child_process.fork` API 生成的进程中。

- https://www.electronjs.org/zh/blog/electron-22-0#utilityprocess-api-36089


> 流程模型 | Electron
> https://www.electronjs.org/zh/docs/latest/tutorial/process-model


