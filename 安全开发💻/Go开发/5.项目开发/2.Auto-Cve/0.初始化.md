
## 前端初始化

### Vite
- 使用vue自动化工具可以快速搭建单页应用项目目录

#### 项目创建
```bash
yarn create vite // 创建
autocve_web
vue --> js

cd autocve_web
yarn // 安装一下依赖库
yarn dev//启动项目
```
   ![](media/Pasted%20image%2020250729053500.png) 
   
```bash
单页面 -- index.html
	<div id="app"></div>

min.js引擎 ---把app.vue--> 塞到index.html
```

#### 项目目录结构介绍

```bash
├─node_modules/   # node的包目录，项目运行的依赖包存储目录，package.json和package-lock.json文件中会自动记录了这个目录下所有的包以及包的版本信息，
├─public/  # 静态资源目录，项目中的静态资源(css，js，图片等文件)放在这个文件夹
├─src/       # 主开发目录，要开发的客户端代码文件（单文件组件，css样式、工具函数等等）全部在这个目录下
    ├─assets/  # 静态资源存储目录，与public目录作用类似。
    ├─router/  # 路由存储目录，是我们创建项目的时候，如果选择安装vue-router，就自动会生成这个目录。
    ├─views/   # 组件页面存储目录，就是浏览器中用户看到的页面内容，views往往会加载并包含components中的组件进来
    ├─components/  # 组件存储目录，就是浏览器中用户看到的页面的一部分内容。
    ├─App.vue
    ├─main.js
    └─style.css
├─index.html
└─package.json   #  如果node_modules没有，但是有package.json，则可以在终端下，通过npm install进行恢复node_modules所有内容。
```

#### 项目执行流程图

![](media/Pasted%20image%2020250729055510.png)  

```
src/views/各个页面.vue

在app中导入组件
```

![](media/Pasted%20image%2020250729180234.png)  

#### 公共组件
```vue
src/componets
 Header.vue
 Footer.vue



<script setup>  
import WebData  from "./views/WebData.vue";  
import Header  from "./components/Header.vue";  
import Footer  from "./components/Footer.vue";  
</script>  
  
<template>  
  <div>  
    <Header />  
    <WebData />  
    <Footer />  
  </div>  
  
</template>  
  
<style scoped>  
  
</style>
```

#### css样式清除

清空src/App.vue的代码内容，代码：

```vue
<template>

</template>

<script setup>

</script>

<style>

</style>
```

清空src/style.css的样式内容，并根据`https://github.com/necolas/normalize.css`，补充css样式初始化代码。

```css
/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */

/* Document
   ========================================================================== */

/**
 * 1. Correct the line height in all browsers.
 * 2. Prevent adjustments of font size after orientation changes in iOS.
 */

html {
  line-height: 1.15; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
}

/* Sections
   ========================================================================== */

/**
 * Remove the margin in all browsers.
 */

body {
  margin: 0;
}

/**
 * Render the `main` element consistently in IE.
 */

main {
  display: block;
}

/**
 * Correct the font size and margin on `h1` elements within `section` and
 * `article` contexts in Chrome, Firefox, and Safari.
 */

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

/* Grouping content
   ========================================================================== */

/**
 * 1. Add the correct box sizing in Firefox.
 * 2. Show the overflow in Edge and IE.
 */

hr {
  box-sizing: content-box; /* 1 */
  height: 0; /* 1 */
  overflow: visible; /* 2 */
}

/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd `em` font sizing in all browsers.
 */

pre {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}

/* Text-level semantics
   ========================================================================== */

/**
 * Remove the gray background on active links in IE 10.
 */

a {
  background-color: transparent;
}

/**
 * 1. Remove the bottom border in Chrome 57-
 * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.
 */

abbr[title] {
  border-bottom: none; /* 1 */
  text-decoration: underline; /* 2 */
  text-decoration: underline dotted; /* 2 */
}

/**
 * Add the correct font weight in Chrome, Edge, and Safari.
 */

b,
strong {
  font-weight: bolder;
}

/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd `em` font sizing in all browsers.
 */

code,
kbd,
samp {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}

/**
 * Add the correct font size in all browsers.
 */

small {
  font-size: 80%;
}

/**
 * Prevent `sub` and `sup` elements from affecting the line height in
 * all browsers.
 */

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/* Embedded content
   ========================================================================== */

/**
 * Remove the border on images inside links in IE 10.
 */

img {
  border-style: none;
}

/* Forms
   ========================================================================== */

/**
 * 1. Change the font styles in all browsers.
 * 2. Remove the margin in Firefox and Safari.
 */

button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-size: 100%; /* 1 */
  line-height: 1.15; /* 1 */
  margin: 0; /* 2 */
}

/**
 * Show the overflow in IE.
 * 1. Show the overflow in Edge.
 */

button,
input { /* 1 */
  overflow: visible;
}

/**
 * Remove the inheritance of text transform in Edge, Firefox, and IE.
 * 1. Remove the inheritance of text transform in Firefox.
 */

button,
select { /* 1 */
  text-transform: none;
}

/**
 * Correct the inability to style clickable types in iOS and Safari.
 */

button,
[type="button"],
[type="reset"],
[type="submit"] {
  -webkit-appearance: button;
}

/**
 * Remove the inner border and padding in Firefox.
 */

button::-moz-focus-inner,
[type="button"]::-moz-focus-inner,
[type="reset"]::-moz-focus-inner,
[type="submit"]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}

/**
 * Restore the focus styles unset by the previous rule.
 */

button:-moz-focusring,
[type="button"]:-moz-focusring,
[type="reset"]:-moz-focusring,
[type="submit"]:-moz-focusring {
  outline: 1px dotted ButtonText;
}

/**
 * Correct the padding in Firefox.
 */

fieldset {
  padding: 0.35em 0.75em 0.625em;
}

/**
 * 1. Correct the text wrapping in Edge and IE.
 * 2. Correct the color inheritance from `fieldset` elements in IE.
 * 3. Remove the padding so developers are not caught out when they zero out
 *    `fieldset` elements in all browsers.
 */

legend {
  box-sizing: border-box; /* 1 */
  color: inherit; /* 2 */
  display: table; /* 1 */
  max-width: 100%; /* 1 */
  padding: 0; /* 3 */
  white-space: normal; /* 1 */
}

/**
 * Add the correct vertical alignment in Chrome, Firefox, and Opera.
 */

progress {
  vertical-align: baseline;
}

/**
 * Remove the default vertical scrollbar in IE 10+.
 */

textarea {
  overflow: auto;
}

/**
 * 1. Add the correct box sizing in IE 10.
 * 2. Remove the padding in IE 10.
 */

[type="checkbox"],
[type="radio"] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Correct the cursor style of increment and decrement buttons in Chrome.
 */

[type="number"]::-webkit-inner-spin-button,
[type="number"]::-webkit-outer-spin-button {
  height: auto;
}

/**
 * 1. Correct the odd appearance in Chrome and Safari.
 * 2. Correct the outline style in Safari.
 */

[type="search"] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/**
 * Remove the inner padding in Chrome and Safari on macOS.
 */

[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}

/**
 * 1. Correct the inability to style clickable types in iOS and Safari.
 * 2. Change font properties to `inherit` in Safari.
 */

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/* Interactive
   ========================================================================== */

/*
 * Add the correct display in Edge, IE 10+, and Firefox.
 */

details {
  display: block;
}

/*
 * Add the correct display in all browsers.
 */

summary {
  display: list-item;
}

/* Misc
   ========================================================================== */

/**
 * Add the correct display in IE 10+.
 */

template {
  display: none;
}

/**
 * Add the correct display in IE 10.
 */

[hidden] {
  display: none;
}

/* 声明全局样式和项目的初始化样式 */
body,h1,h2,h3,h4,p,table,tr,td,ul,li,a,form,input,select,option,textarea{
  margin:0;
  padding: 0;
  font-size: 15px;
}
a{
  text-decoration: none;
  color: #333;
  cursor: pointer;
}
ul,li{
  list-style: none;
}
table{
  border-collapse: collapse; /* 合并边框 */
}
img{
  max-width: 100%;
  max-height: 100%;
}
input{
  outline: none;
}

```

#### 主页面板组件 -- 路由
终端下安装router路由模块，命令如下：

```bash
cd autocve_web  # 注意，客户端安装模块的所有命令，务必在package.json所在目录下操作。
yarn add vue-router
```

`src/router/index.js`，路由对象初始化，代码：

```javascript
import { createRouter, createWebHistory } from 'vue-router'  
  
  
const routes = [  
    { path: '/', name: 'AutoCve', component: ()=>import("../views/AutoCve.vue")},  // 主页面板  
    { path: '/webdata', name: 'Webdata', component: ()=>import("../views/WebData.vue")}  
]  
  
const router = createRouter({  
    history: createWebHistory(),  
    routes  
});  
  
  
export default router;
```

`src/main.js`，加载路由对象，代码：

```javascript
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import router from './router'

createApp(App).use(router).mount('#app')

```

`src/App.vue`，代码：

```vue
<script setup>  
  
</script>  
  
<template>  
  <router-view/>  
</template>  
  
  
  
<style scoped>  
  
</style>
```

src目录下创建views页面组件目录并新建bingo.vue组件，`src/views/AutoCve.vue`，代码：

```vue
<template>
<h3>AutoCve主页面板</h3>
</template>

<script>
export default {
  name: "AutoCve"
}
</script>

<style scoped>

</style>
```

### 组件
#### Ant-Design

- https://www.antdv.com/components/overview-cn/
- 安装
```bash
yarn add ant-design-vue
```


在`src/main.js`文件中引入Antd框架。代码：

```javascript
import { createApp } from 'vue'  
import './style.css'  
import App from './App.vue'  
import router from './router'  
import Antd from 'ant-design-vue';  
  
createApp(App).use(router).use(Antd).mount('#app')
```

下面我们在`src/views/autocve.vue`页面组件中引入一个ant-design的button按钮，查看是否成功安装并引入。

文档：https://next.antdv.com/components/button-cn

代码：

```vue
<template>
  <div>站点首页</div>
  <a-button type="primary">Primary Button</a-button>
</template>

<script setup>

</script>

<style scoped>
/* 子组件中所有的css样式，都应该是局部的，只作用于当前组件，所以需要设置scoped属性 */

</style>
```

#### 图表组件

作为一个运维项目，很多时候需要基于图表可视化展示服务器相关数据，所以我们还需要借助图表开源插件，比如echarts和Highcharts，我们本次采用的是百度开源的echarts。

Echarts官方：https://echarts.apache.org/zh/index.html

命令如下：

```bash
cd autocve_web  # 注意，客户端安装模块的所有命令，务必在package.json所在目录下操作。
yarn add echarts
```

安装完成以后，直接可以在`src/views/autocve.vue`页面组件中进行使用Echarts基本示例查看效果，代码：
```vue
-- 补充 Vue定位标签

<div class="chart" ref="chart"></div>
<script setup>
import {onMounted, ref} from 'vue';

const chart = ref();   // 之后chart 就会直接定位到 <div class="chart" ref="chart">这里

onMounted(() => {   // onMounted页面已加载就执行

  console.log(":::", chart.value)
  let myChart = echarts.init(chart.value);
  myChart.setOption(option);
})  

</script>
```


```vue
<template>
  <div>站点首页</div>
  <a-button type="primary">Primary Button</a-button>
  <div class="chart" ref="chart"></div>
</template>

<script setup>
import {onMounted, ref} from 'vue';
import * as echarts from 'echarts';

const chart = ref();
const option = {
  title: {
    text: 'Referer of a Website',
    subtext: 'Fake Data',
    left: 'center'
  },
  tooltip: {
    trigger: 'item'
  },
  legend: {
    orient: 'vertical',
    left: 'left'
  },
  series: [
    {
      name: 'Access From',
      type: 'pie',
      radius: '50%',
      data: [
        {value: 1048, name: 'Search Engine'},
        {value: 735, name: 'Direct'},
        {value: 580, name: 'Email'},
        {value: 484, name: 'Union Ads'},
        {value: 300, name: 'Video Ads'}
      ],
      emphasis: {
        itemStyle: {
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowColor: 'rgba(0, 0, 0, 0.5)'
        }
      }
    }
  ]
};
onMounted(() => {

  console.log(":::", chart.value)
  let myChart = echarts.init(chart.value);
  myChart.setOption(option);
})
</script>

<style scoped>
/* 子组件中所有的css样式，都应该是局部的，只作用于当前组件，所以需要设置scoped属性 */
.chart {
  width: 500px;
  height: 500px;
  float: left;
  margin: 0 auto 0 100px;
}
</style>
```


### 页面展示

#### 首页面板

#### 公共页面

>由于除了登录页面之外我们后面所有的组件都具备顶部导航栏和左侧菜单栏的效果，所以我们可以直接将公共部分页面内容放到了一个Base.vue组件中，里面通过 ant design vue中的布局组件来组织页面排版。
- `src/base.vue`
- https://www.antdv.com/components/layout-cn
- 路由连接
`src/views/Base.vue`，代码：
```vue
<template>
  <a-layout style="min-height: 100vh">
    <a-layout-sider v-model:collapsed="collapsed" collapsible>
      <div class="logo" />
      <a-menu v-model:selectedKeys="selectedKeys" theme="dark" mode="inline">
        <a-menu-item key="1">
          <pie-chart-outlined />
          <span>Option 1</span>
        </a-menu-item>
        <a-menu-item key="2">
          <desktop-outlined />
          <span>Option 2</span>
        </a-menu-item>
        <a-sub-menu key="sub1">
          <template #title>
            <span>
              <user-outlined />
              <span>User</span>
            </span>
          </template>
          <a-menu-item key="3">Tom</a-menu-item>
          <a-menu-item key="4">Bill</a-menu-item>
          <a-menu-item key="5">Alex</a-menu-item>
        </a-sub-menu>
        <a-sub-menu key="sub2">
          <template #title>
            <span>
              <team-outlined />
              <span>Team</span>
            </span>
          </template>
          <a-menu-item key="6">Team 1</a-menu-item>
          <a-menu-item key="8">Team 2</a-menu-item>
        </a-sub-menu>
        <a-menu-item key="9">
          <file-outlined />
          <span>File</span>
        </a-menu-item>
      </a-menu>
    </a-layout-sider>
    <a-layout>
      <a-layout-header style="background: #fff; padding: 0" />
      <a-layout-content style="margin: 0 16px">
        <a-breadcrumb style="margin: 16px 0">
          <a-breadcrumb-item>User</a-breadcrumb-item>
          <a-breadcrumb-item>Bill</a-breadcrumb-item>
        </a-breadcrumb>
        <div :style="{ padding: '24px', background: '#fff', minHeight: '360px' }">
          Bill is a cat.
        </div>
      </a-layout-content>
      <a-layout-footer style="text-align: center">
        Ant Design ©2018 Created by Ant UED
      </a-layout-footer>
    </a-layout>
  </a-layout>
</template>
<script setup>
import { PieChartOutlined, DesktopOutlined, UserOutlined, TeamOutlined, FileOutlined } from '@ant-design/icons-vue';
import { ref } from 'vue';

const collapsed = ref(false);
const selectedKeys = ref(['1']);
</script>

<style>
#components-layout-demo-side .logo {
  height: 32px;
  margin: 16px;
  background: rgba(255, 255, 255, 0.3);
}

.site-layout .site-layout-background {
  background: #fff;
}
[data-theme='dark'] .site-layout .site-layout-background {
  background: #141414;
}
</style>
```

先注释掉原来的`autocve.vue`组件的路由信息，`src/rouer/index.js`，代码：
```javascript
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  // { path: '/autocve', meta: {title: "主页面板"}, name: 'autocve', component: ()=>import("../views/autocve.vue")},
  { path: '/autocve', meta: {title: ""}, name: 'Base', component: ()=>import("../views/Base.vue")},
]

const router = createRouter({
  history: createWebHistory(),
  routes
});

router.beforeEach((to, from, next) => {
  if(to.meta.title){
    // 修改页面原有标题
    document.title = to.meta.title
  }
  next();
});

export default router;
```

实现页面嵌套

`src/views/Base.vue`，代码：

```vue
<template>
  <a-layout style="min-height: 100vh">
    <a-layout-sider v-model:collapsed="collapsed" collapsible>
      <div class="logo">
        <span>autocve</span>
      </div>
      <a-menu v-for="menu in menu_list" v-model:selectedKeys="selectedKeys" theme="dark" mode="inline">
        <a-menu-item v-if="menu.children.length===0" :key="menu.id">
          <router-link :to="menu.menu_url">
            <desktop-outlined/>
            <span> {{ menu.title }}</span>
          </router-link>
        </a-menu-item>
        <a-sub-menu v-else :key="menu.id">
          <template #title>
            <span>
              <user-outlined/>
              <span>{{ menu.title }}</span>
            </span>
          </template>
          <a-menu-item v-for="child_menu in menu.children" :key="child_menu.id">
            <router-link :to="child_menu.menu_url">{{ child_menu.title }}</router-link>
          </a-menu-item>
        </a-sub-menu>
      </a-menu>
    </a-layout-sider>
    <a-layout>
      <a-layout-header style="background: #fff;text-align: center">
        <a-row>
          <a-col :span="2" :offset="22">
            <a-dropdown placement="bottom">
              <p class="user"><UserOutlined /> root</p>
              <template #overlay>
                <a-menu>
                  <a-menu-item><LockOutlined/> 修改密码</a-menu-item>
                  <a-menu-item><LogoutOutlined/> 退出登陆</a-menu-item>
                </a-menu>
              </template>
            </a-dropdown>
          </a-col>
        </a-row>
      </a-layout-header>
      <a-layout-content style="margin: 0 16px">
        <a-breadcrumb style="margin: 16px 0">
          <a-breadcrumb-item><a href="">首页</a></a-breadcrumb-item>
          <a-breadcrumb-item>信息面板</a-breadcrumb-item>
        </a-breadcrumb>
        <div :style="{ padding: '24px', background: '#fff', minHeight: '550px'}">
          <router-view></router-view>
        </div>
      </a-layout-content>
      <a-layout-footer style="text-align: center">
        <p>Copyright © 2023 autocve</p>
        Power By <a href="">LinMo Jiang &amp; Bazinga Yuan</a>
      </a-layout-footer>
    </a-layout>
  </a-layout>
</template>
<script setup>
import { LogoutOutlined, LockOutlined, DesktopOutlined, UserOutlined} from '@ant-design/icons-vue';
import { ref } from 'vue';

const collapsed = ref(false);
const selectedKeys = ref(['1']);

const menu_list = ref([
  {
    id: 1, icon: 'mail', title: '信息面板', menu_url: '/autocve/', children: []
  },
  {
    id: 2, icon: 'mail', title: '资产管理', menu_url: '/autocve/manage', children: [
      {id: 9, icon: 'mail', title: '主机管理', menu_url: '/autocve/manage/host'},
      {id: 10, icon: 'mail', title: 'DB管理', menu_url: '/autocve/manage/db'},
      {id: 11, icon: 'mail', title: 'IDC机房', menu_url: '/autocve/manage/idc'},
      {id: 12, icon: 'mail', title: '资产配置', menu_url: '/autocve/manage/config'},
    ]
  },
  {
    "id": 3, icon: 'bold', title: '作业管理', menu_url: '/autocve/work', children: [
      {id: 13, icon: 'mail', title: '批量任务', menu_url: '/autocve/work/tasks'},
      {id: 14, icon: 'mail', title: '计划任务', menu_url: '/autocve/work/cron', children: []},
      {id: 15, icon: 'mail', title: '任务模板', menu_url: '/autocve/work/template'},
    ]
  },
  {
    id: 4, icon: 'highlight', title: '代码管理', menu_url: '/autocve/code', children: [
      {id: 16, icon: 'mail', title: '应用管理', menu_url: '/autocve/code/app'},
      {id: 17, icon: 'mail', title: '发布申请', menu_url: '/autocve/code/release'},
      {id: 18, icon: 'mail', title: '代码仓库', menu_url: '/autocve/code/repo'},
      {id: 19, icon: 'mail', title: '镜像仓库', menu_url: '/autocve/code/image'},
    ]
  },
  {
    id: 5, icon: 'mail', title: '配置管理', menu_url: '/autocve/config', children: [
      {id: 20, title: '环境管理', menu_url: '/autocve/config/env'},
      {id: 21, title: '服务配置', menu_url: '/autocve/config/services'},
      {id: 22, title: '应用配置', menu_url: '/autocve/config/app'}
    ]
  },
  {
    id: 6, icon: 'mail', title: '监控预警', menu_url: '/autocve/monitor', children: [
      {id: 23, title: '报警历史', menu_url: '/autocve/monitor/history'},
      {id: 24, title: '报警联系人', menu_url: '/autocve/monitor/user'},
      {id: 25, title: '报警联系组', menu_url: '/autocve/monitor/group'}
    ]
  },
  {
    id: 7, icon: 'mail', title: '用户管理', menu_url: '/autocve/auth', children: [
      {id: 26, title: '账户管理', menu_url: '/autocve/auth/user'},
      {id: 27, title: '角色管理', menu_url: '/autocve/auth/role'},
      {id: 28, title: '权限管理', menu_url: '/autocve/auth/permission'},
      {id: 29, title: '菜单管理', menu_url: '/autocve/auth/menu'},
    ]
  },
  {
    id: 8, icon: 'mail', title: '系统设置', menu_url: '/autocve/sys', children: []
  },
])

</script>

<style>
.logo {
  font-style: italic;
  text-align: center;
  font-size: 20px;
  color:#fff;
  margin: 0 0 10px;
  line-height: 42px;
  height: 42px;
  background: rgba(255, 255, 255, 0.1);
}
.user{
  position: relative;
}
.user:after{
  content: "";
  border: 4px solid transparent;
  border-top: 4px solid #000;
  position: absolute;
  width: 0;
  height: 0;
  top: 30px;
  right: 12px;
  margin: auto;
}

</style>
```

基于router的嵌套子路由实现页面嵌套效果，所以在上面56行代码中，我们使用了`<router-view></router-view>`用于提供给路由组件将来替换子模板内容，接下来，我们还需要修改下路由配置才能看到真正效果。`src/router/index.js`，代码：

```javascript
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  { path: '/autocve', meta: {title: ""}, name: 'Base', component: ()=>import("../views/Base.vue"), children: [
      { path: '', meta: {title: "主页面板"}, name: 'autocve', component: ()=>import("../views/autocve.vue")},
    ]},
]

const router = createRouter({
  history: createWebHistory(),
  routes
});

router.beforeEach((to, from, next) => {
  if(to.meta.title){
    // 修改页面原有标题
    document.title = to.meta.title
  }
  next();
});

export default router;
```
#### 登录页面

![](media/Pasted%20image%2020250729221711.png)  
src/views/Login.vue，代码：

```vue
<template>
  <div class="login box">
    <img src="../assets/login.jpg" alt="">
    <div class="login">
      <div class="login-title">
        <p class="hi">Hello,autocve!</p>
      </div>
      <div class="login_box">
        <div class="title">
          <span>登录</span>
        </div>
        <div class="inp">
          <a-input v-model:value="username" type="text" placeholder="用户名" class="user"></a-input>
          <a-input v-model:value="password" type="password" class="pwd" placeholder="密码"></a-input>
          <div class="remember">
            <a-checkbox type="checkbox" v-model:checked="remember">记住密码</a-checkbox>
          </div>
          <button class="login_btn" @click="login">登录</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import {ref} from "vue";

const username = ref('');
const password = ref('');
const remember = ref(true);

const login = () => {

}
</script>

<style scoped>
.login.box {
  overflow: hidden;
  height: 100vh;
}

.login .hi {
  font-size: 20px;
  font-style: italic;
}

.box {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

.box img {
  width: 100%;
  min-height: 100%;
}

.box .login {
  position: absolute;
  width: 500px;
  height: 400px;
  left: 0;
  margin: auto;
  right: 0;
  bottom: 0;
  top: -338px;
}

.login .login-title {
  width: 100%;
  text-align: center;
}

.login-title img {
  width: 190px;
  height: auto;
}

.login-title p {
  font-size: 18px;
  color: #fff;
  letter-spacing: .29px;
  padding-top: 10px;
  padding-bottom: 50px;
}

.login_box {
  width: 400px;
  height: auto;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .5);
  border-radius: 4px;
  margin: 0 auto;
  padding-bottom: 40px;
}

.login_box .title {
  font-size: 20px;
  color: #9b9b9b;
  letter-spacing: .32px;
  border-bottom: 1px solid #e6e6e6;
  display: flex;
  justify-content: space-around;
  padding: 50px 60px 0 60px;
  margin-bottom: 20px;
  cursor: pointer;
}

.login_box .title span:nth-of-type(1) {
  color: #4a4a4a;
  border-bottom: 2px solid #396fcc;
}

.inp {
  width: 350px;
  margin: 0 auto;
}

.inp input {
  outline: 0;
  width: 100%;
  height: 45px;
  border-radius: 4px;
  border: 1px solid #d9d9d9;
  text-indent: 20px;
  font-size: 14px;
  background: #fff !important;
}

.inp .user {
  margin-bottom: 16px;
}

.login_btn {
  width: 100%;
  height: 45px;
  background: #396fcc;
  border-radius: 5px;
  font-size: 16px;
  color: #fff;
  letter-spacing: .26px;
  margin-top: 30px;
}

.remember {
  margin-top: 10px;
}
</style>
```

登陆页面不存在菜单等公共部分页面，所以我们单独注册路由，`src/router/index.js`，代码：

```javascript
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  { path: '/autocve', meta: {title: ""}, name: 'Base', component: ()=>import("../views/Base.vue"), children: [
      { path: '', meta: {title: "主页面板"}, name: 'autocve', component: ()=>import("../views/autocve.vue")},
      { path: 'manage/host', meta: {title: "主机管理"}, name: 'Host', component: ()=>import("../views/Host.vue")},
    ]},

  { path: '/', meta: {title: "用户登录"}, name: 'Login', component: ()=>import("../views/Login.vue")},
]

const router = createRouter({
  history: createWebHistory(),
  routes
});

router.beforeEach((to, from, next) => {
  if(to.meta.title){
    // 修改页面原有标题
    document.title = to.meta.title
  }
  next();
});

export default router;

```
  
### 路由守卫
```vue

router.beforeEach((to, from, next) => {
  if(to.meta.title){
    // 修改页面原有标题
    document.title = to.meta.title
  }
  next();
});

```



## 后端初始化

### 搭建项目

```bash
mkdir autocve_api
cd autocve_api
go mod init autocve_api
```

### 目录结构

```bash
└── autocve_api/
     ├── logs/          # 项目运行时/开发时日志目录
     └── application/   # 开发主应用目录
          ├── api/        # 接口层目录
          ├── config/     # 配置目录
          ├── constants/  # 全局常量目录
          ├── initialize/ # 项目初始化目录
          ├── middleware/ # 中间件层目录
          ├── model/      # 模型层目录
          ├── router/     # 路由目录
          ├── services/   # 业务层目录
          ├── utils/      # 工具库目录
          ├── validator/  # 验证逻辑目录
          └── main.go     # 项目入口文件
```

上面的目录结构图可以在终端下使用tree输出。如果没有安装tree，安装下就有了。

安装gin框架

```bash
go get -u github.com/gin-gonic/gin
```

`application/main.go`，代码：
```go
package main  
  
import (  
    . "autocve_api/application/database"  
    "github.com/gin-gonic/gin"    "net/http")  
  
func main() {  
    r := gin.Default()  
  
    InitMysql() // 初始化数据库连接  
    r.GET("/", func(c *gin.Context) {  
       c.String(http.StatusOK, "Hello autocve!")  
    })  
    r.Run(":8081") // 启动服务，监听8081端口  
}

```

### 路由初始化
`application/main.go`，代码：
```go
package main

import (
	"autocve_api/application/initialize"
)

func main() {
	// 1. 路由初始化
	Router := initialize.InitRouter()
	// 2.监听端口，默认在8080
	Router.Run(":8080")
}
```

`application/initialize/router.go`，代码：

```go
package initialize

import (
	"github.com/gin-gonic/gin"
)

func InitRouter() *gin.Engine {

	// 1. 创建路由
	Router := gin.Default()
	// 2. Api路由分组
	ApiGroup := Router.Group("/test")
	ApiGroup.GET("/", func(context *gin.Context) {
		context.String(200, "autocve Start")
	})

	return Router
}
```

### 配置初始化
```go
go get github.com/spf13/viper
```

初始化配置模块，`application/config/config.go`，代码：

```go
package config  
  
import (  
    "github.com/spf13/viper"  
    "path/filepath"    "runtime"    "sync")  
  
// 全局配置实例  
var (  
    cfg     *viper.Viper  
    cfgOnce sync.Once  
)  
  
// InitConfig 初始化全局配置  
func InitConfig() *viper.Viper {  
    cfgOnce.Do(func() {  
       // 获取当前文件路径（config.go的位置）  
       _, currentFile, _, _ := runtime.Caller(0)  
  
       // 项目根目录：config.go 所在目录的上一级  
       projectRoot := filepath.Dir(filepath.Dir(currentFile))  
  
       // 配置文件位于项目根目录  
       configPath := filepath.Join(projectRoot, "config.yaml")  
  
       // 创建新的 Viper 实例  
       v := viper.New()  
  
       // 设置配置文件路径  
       v.SetConfigFile(configPath)  
  
       // 读取配置文件（忽略文件不存在的错误）  
       if err := v.ReadInConfig(); err != nil {  
          if _, ok := err.(viper.ConfigFileNotFoundError); !ok {  
             panic("读取配置文件错误: " + err.Error())  
          }  
       }  
  
       cfg = v  
    })  
  
    return cfg  
}  
  
// GetConfig 获取全局配置实例  
func GetConfig() *viper.Viper {  
    if cfg == nil {  
       return InitConfig()  
    }  
    return cfg  
}
```

准备一个配置文件，项目根目录下创建`config.yaml`，代码：

```json
Basic:  
  port: 8080  
  host: 127.0.0.1  
  mode: debug
```

调用配置初始化函数，`applicaton/main.go`，代码：

```go
package main  
  
import (  
    "autocve_api/application/config"  
    "autocve_api/application/initialize"    
    "fmt"    
    "github.com/gin-gonic/gin"
    )  
  
func main() {  
    // 初始化配置  
    config.InitConfig()  
    
    cfg := config.GetConfig() //以后读取 就这样一下就可以  
    gin.SetMode(cfg.GetString("Basic.mode"))  
  
    // 路由初始化  
    router := initialize.InitRouter()  
  
    /*InitMysql() // 初始化数据库连接*/  
    router.Run(  
       fmt.Sprintf(  
          "%s:%d",  
          cfg.GetString("Basic.host"),  
          cfg.GetInt("Basic.port"))) // 启动服务，监听8081端口  
}
```

### 日志初始化（没写）

>zap是Uber开发的非常快的、结构化的，分日志级别的Go日志库。根据Uber-go Zap的文档，它的性能比类似的结构化日志包更好，也比标准库更快。

github地址：https://github.com/uber-go/zap

安装

```bash
go get -u go.uber.org/zap
go get -u go.uber.org/zap/zapcore
go get -u github.com/natefinch/lumberjack
```

#### 日志等级

从上往下，等级越高。

```golang
DebugLevel   zap.S().Debug  // 调试，开发人员自己调试程序时输入的信息
InfoLevel    zap.S().Info   // 信息，程序在运行过程中，输入的细节信息
WarnLevel    zap.S().Warn   // 警告，程序遇到一些能运行，但是有可能在运行以后出现不预期的结果。                                    
ErrorLevel   zap.S().Error  // 错误，程序遇到了一些功能性上，程序在判断上，出现了预期的错误。
PanicLevel   zap.S().Panic  // 异常，程序遇到了一些功能性上，程序在判断上，出现了不预期的错误。
FatalLevel   zap.S().Fatal  // 致命，程序遇到了致命语法级别错误，根本可能不能运行的，或者运行以后，无法执行的。
```

#### 基本使用

`application/initialize/logger.go`，代码：

```go
package initialize

import "go.uber.org/zap"

func InitLogger() {
	// 日志初始化
	// logger, _ := zap.NewProduction()  // 用于项目生产阶段，格式: json【适合用于集成到第三方日志分析系统中的】
	logger, _ := zap.NewDevelopment()    // 用于项目开发阶段，格式: 普通文本格式【适合在终端查看】
	// 替换了zap的全局日志配置
	zap.ReplaceGlobals(logger)
}

```

`main.go`，代码：

```go
package main

import (
	"autocve_api/application/config"
	"autocve_api/application/initialize"
	"fmt"
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
	"path/filepath"
)

func main() {
	// 获取一个基于整个目录入口所在的路径
	dir, err := filepath.Abs(filepath.Dir("."))
	if err != nil {
		panic(err.Error())
	}

	// 配置初始化
	if err := config.Init(fmt.Sprintf("%s/config.json", dir)); err != nil {
		panic(err.Error())
	}

	// 设置调试模式
	gin.SetMode(config.Conf.Mode)

	// 创建路由
	Router := initialize.InitRouter()

	// 日志初始化
	initialize.InitLogger()
	// zap 提供了一个S函数和L函数给我们开发者使用，调用S函数或L函数，可以得到一个全局的线程安全的logger对象
	zap.S().Infof("服务端启动...端口：%d", config.Conf.Port)

	// 监听端口
	if err := Router.Run(fmt.Sprintf("%s:%d", config.Conf.Host, config.Conf.Port)); err != nil {
		zap.S().Panic("服务端启动失败：", err.Error())
	}
}

```

#### 日志配置

配置文件中指定日志输出的文件名，单个日志文件的大小，周期，以及日志文件的备份数量。

新增日志相关的配置项，`application/config/config.go`，代码：

```go
package config

import (
	"encoding/json"
	"io/ioutil"
)

// Config 整个项目的配置
type Config struct {
	Mode       string `json:"mode"`
  Host       string `json:"host"`
	Port       int    `json:"port"`
	*LogConfig `json:"log"`
}

// LogConfig 日志配置
type LogConfig struct {
	Level      string `json:"level"`
	Filename   string `json:"filename"`
	MaxSize    int    `json:"maxsize"`
	MaxAge     int    `json:"max_age"`
	MaxBackups int    `json:"max_backups"`
}

// Conf 全局配置变量
var Conf = new(Config)

// Init 初始化配置；从指定文件加载配置文件
func Init(filePath string) error {
	b, err := ioutil.ReadFile(filePath)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, Conf)
}

```

`config.json`，代码：

```json
{
  "mode": "debug",
  "host": "api.autocve.cn",
  "port": 8080,
  "log": {
    "level": "debug",
    "filename": "logs/autocve.log",
    "maxsize": 300,
    "max_age": 7,
    "max_backups": 10
  }
}
```

`application/initialize/logger.go`，代码：

```go
package initialize

import (
	"github.com/natefinch/lumberjack"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"autocve_api/application/config"
)

var Logger *zap.Logger

func InitLogger(cfg *config.LogConfig) (err error) {
	// 日志初始化
	// 定制日志的格式
	writeSyncer := getLogWriter(cfg.Filename, cfg.MaxSize, cfg.MaxBackups, cfg.MaxAge)
	encoder := getEncoder()
	var l = new(zapcore.Level)
	if err = l.UnmarshalText([]byte(cfg.Level)); err != nil {
		return
	}
	core := zapcore.NewCore(encoder, writeSyncer, l)
	Logger = zap.New(core, zap.AddCaller())
	// logger, _ := zap.NewProduction()  // 用于项目生产阶段，格式: json【适合用于集成到第三方日志分析系统中的】
	// logger, _ := zap.NewDevelopment()    // 用于项目开发阶段，格式: 普通文本格式【适合在终端查看】
	// 替换了zap的全局日志配置
	zap.ReplaceGlobals(Logger)
	return
}

func getEncoder() zapcore.Encoder {
	encoderConfig := zap.NewProductionEncoderConfig()
	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	encoderConfig.TimeKey = "time"
	encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
	encoderConfig.EncodeDuration = zapcore.SecondsDurationEncoder
	encoderConfig.EncodeCaller = zapcore.ShortCallerEncoder
	return zapcore.NewJSONEncoder(encoderConfig)
}

func getLogWriter(filename string, maxSize, maxBackup, maxAge int) zapcore.WriteSyncer {
	lumberJackLogger := &lumberjack.Logger{
		Filename:   filename,
		MaxSize:    maxSize,
		MaxBackups: maxBackup,
		MaxAge:     maxAge,
	}
	return zapcore.AddSync(lumberJackLogger)
}

```

`application/main.go`，代码：

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
	"path/filepath"
	"autocve_api/application/config"
	"autocve_api/application/initialize"
)

func main() {
	// 1. 获取一个基于整个目录入口所在的路径
	dir, err := filepath.Abs(filepath.Dir("."))
	if err != nil {
		panic(err.Error())
	}

	// 2. 配置初始化
	if err := config.Init(fmt.Sprintf("%s/config.json", dir)); err != nil {
		panic(err.Error())
	}

	// 设置调试模式
	gin.SetMode(config.Conf.Mode)

	// 3. 日志初始化
	if err := initialize.InitLogger(config.Conf.LogConfig); err != nil {
		fmt.Printf("init logger failed, err:%v\n", err)
		return
	}

	zap.S().Debugf("调试信息:%d", config.Conf.Port)

	// 4.创建路由
	Router := initialize.InitRouter()

	// 5. zap 提供了一个S函数和L函数给我们开发者使用，调用S函数或L函数，可以得到一个全局的线程安全的logger对象
	zap.S().Infof("服务端启动...端口：%d", config.Conf.Port)

	// 监听端口
	if err := Router.Run(fmt.Sprintf("%s:%d", config.Conf.Host, config.Conf.Port)); err != nil {
		zap.S().Panic("服务端启动失败：", err.Error())
	}
}

```

中间件中对每次的请求响应进行日志记录，`application/middleware/logger.go`，代码：

```go
package middleware

import (
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
	"net"
	"net/http"
	"net/http/httputil"
	"os"
	"runtime/debug"
	"strings"
	"time"
)

// GinLogger 接收gin框架默认的日志
func GinLogger() gin.HandlerFunc {
	// 需要记录的是每次客户端访问时的上下文信息，所以此处返回一个匿名函数，在客户端请求时，触发中间件的时候，自动执行这个匿名函数
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		c.Next()
		cost := time.Since(start)
		// 记录日志
		zap.S().Info(path,
			zap.Int("status", c.Writer.Status()),
			zap.String("method", c.Request.Method),
			zap.String("ip", c.ClientIP()),
			zap.String("user-agent", c.Request.UserAgent()),
			zap.Duration("cost timer", cost),
		)
	}
}

```

注册中间件，`application/initialize/router.go`，代码：

```go
package initialize

import (
	"autocve_api/application/middleware"
	"github.com/gin-gonic/gin"
)

func InitRouter() *gin.Engine {

	// 1. 创建路由
	Router := gin.Default()
	Router.Use(middleware.GinLogger())

	// 2. Api路由分组
	ApiGroup := Router.Group("/test")

	ApiGroup.GET("/", func(context *gin.Context) {
		context.String(200, "autocve Start")
	})

	return Router
}
```

### 全局异常处理

`applicaton/middleware/exceptions.go`，代码：

```go
package middleware

import (
	"github.com/gin-gonic/gin"
	"go.uber.org/zap"
	"net/http"
)

type Api struct {
	Code    int
	Message string
}

func ExceptionMiddleware(c *gin.Context) {
	 /**
	 异常处理
	 */
	defer func() {
		if r := recover(); r != nil {
			switch t := r.(type) {
			case *Api:
				zap.S().Error(t.Message)
				c.JSON(t.Code, gin.H{
					"message": t.Message,
				})
			default:
				zap.S().Error("服务器内部异常")
				c.JSON(http.StatusInternalServerError, gin.H{
					"message": "服务器内部异常",
				})
			}
			c.Abort()
		}
	}()

	c.Next()
}
```

`initialize/router.go`，代码：

```go
Router.Use(middleware.ExceptionMiddleware)
```


### mysql的初始化

#### 创建数据库

```mysql
create database autocve default charset=utf8mb4;
-- mysql5.5以后推出的utf8mb4，这个是真正的utf8，能够容纳所有的中文，以前的utf-8会出现错乱的中文编码。
```

为当前项目创建数据库用户[这个用户只能看到autocve这个数据库]

```mysql
# 创建用户：create user '用户名'@'主机地址' identified by '密码';
create user 'autocve_user'@'%' identified by 'autocve';  # %表示任意主机都可以通过当前账户登录到mysql
# 分配权限：grant 权限选项 on 数据库名.数据表 to '用户名'@'主机地址' with grant option;
grant all privileges on autocve.* to 'autocve_user'@'%' with grant option;
```

#### MySQL初始化

文档：https://gorm.io/zh_CN/docs/

增加数据库连接的配置项，`config/config.go`，代码：

```go
package config

import (
	"encoding/json"
	"io/ioutil"
)

// 外界go开发项目： 配置文件都是 json、yaml、ini

// LogConfig 日志配置
type LogConfig struct {
	Level      string `json:"level"`
	Filename   string `json:"filename"`
	MaxSize    int    `json:"maxsize"`
	MaxAge     int    `json:"max_age"`
	MaxBackups int    `json:"max_backups"`
}

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
	Driver          string `json:"driver"`
	Host            string `json:"host"`
	Port            string `json:"port"`
	Database        string `json:"database"`
	Username        string `json:"username"`
	Password        string `json:"password"`
	Charset         string `json:"charset"`
	MaximumConn     int    `json:"maximum_connection"`
	MaximumFreeConn int    `json:"maximum_free_connection"`
	TimeOut         int    `json:"timeout"`
}

// Config 整个项目的配置
type Config struct {
	Mode            string `json:"mode"`
  Host            string `json:"host"`
	Port            int    `json:"port"`
	*LogConfig      `json:"log"`
	*DatabaseConfig `json:"database"`
}

// Conf 全局配置变量
var Conf = new(Config)

// Init 初始化配置；从指定文件加载配置文件
func Init(filePath string) error {
	/**
	filePath 配置文件json文件的路径
	*/
	b, err := ioutil.ReadFile(filePath)
	if err != nil {
		return err
	}
	return json.Unmarshal(b, Conf)
}
```

增加数据库连接的配置项，`applicetion/config.yaml`，代码：

```json
Basic:  
  port: 8080  
  host: 127.0.0.1  
  mode: debug  
  
Mysql:  
  host: localhost  
  port: 3306  
  user: autocve  
  password: autocve123  
  database: autocve_db
```

封装初始化数据库连接工具函数，`applicetion/database/mysql.go`，代码：

```go
package database  
  
import (  
    . "autocve_api/application/model"  
    "fmt"    "github.com/spf13/viper"    "gorm.io/driver/mysql"    "gorm.io/gorm"    "gorm.io/gorm/logger"    "log"    "os")  
  
var DB *gorm.DB  
  
func GetOrm(cfg *viper.Viper) *gorm.DB {  
    fmt.Println("数据库初始化")  
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=true&loc=Local",  
       cfg.GetString("Mysql.username"),  
       cfg.GetString("Mysql.password"),  
       cfg.GetString("Mysql.host"),  
       cfg.GetString("Mysql.port"),  
       cfg.GetString("Mysql.database"),  
    )  
  
    newLogger := logger.New(  
       log.New(os.Stdout, "\r\n", log.LstdFlags),  
       logger.Config{  
          LogLevel: logger.Info,  
       },  
    )  
  
    var err error  
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{Logger: newLogger})  
    if err != nil {  
       log.Fatalf("连接数据库失败: %v", err)  
    }  
  
    return DB  
}

/*
最大连接数（MaxOpenConns）：它限制了连接池中可以同时打开的连接数量。
通过设置最大连接数，可以防止过多的连接同时被创建，从而避免数据库服务器过载或资源耗尽的情况。
如果达到最大连接数限制，新的数据库连接请求将被阻塞，直到有连接被释放回连接池。

最大空闲连接数（MaxIdleConns）：它限制了连接池中可以保持空闲的连接数量。
连接池中的空闲连接可以避免频繁地创建和销毁连接，从而提高性能。
设置适当的最大空闲连接数可以根据应用程序的负载情况平衡连接的创建和销毁成本，确保连接池中始终有足够的连接供应用程序使用。

设置连接的最大生命周期可以确保连接在一段时间后被释放，以防止连接长时间保持打开状态而导致资源耗尽。
*/

```

`applicetion/initialize/db.go`，代码：

```go
package initialize

import (
	"autocve_api/application/config"
	"autocve_api/application/database"
	"autocve_api/application/model"
)

func InitDB(cfg *config.DatabaseConfig) {
	Orm := database.GetOrm(cfg)
	Orm.AutoMigrate(&model.User{})
	// 禁用复数
	Orm.SingularTable(true)
}

```

`main.go`，代码：

```go
// 数据库初始化
initialize.InitDB(config.Conf.DatabaseConfig)
```

### 热自启

要在 Go Gin 项目中实现热重启（Hot Reload），可以使用第三方工具 `fresh`。`fresh` 是一个 Go 应用程序的自动重启工具，它能够在代码发生变化时重新编译并启动应用程序。

```bash
go get -u github.com/pilu/fresh
```

修改dir的值即可，`autocve_api/application/main.go`

终端下要在main.go入门程序所在位置，运行执行如下命令：

```bash
fresh
```

### axios&跨域支持

#### 安装配置axios

后面需要获取服务端的api接口数据，意味着要发送http请求，我们使用axios模块来请求服务端。

```bash
cd autocve_web  # 注意，客户端安装模块的所有命令，务必在package.json所在目录下操作。
yarn add axios
```

创建`src/http/index.js`，编写axos对象初始化代码：

```javascript
import axios from "axios";
import settings from "../settings";

const http =  axios.create({
  baseURL: settings.host,
  withCredentials: false,
})

// 请求拦截器
http.interceptors.request.use((config)=>{
    console.log("http请求之前进行请求头组装，会自动执行请求拦截器");
    return config;
}, (error)=>{
    console.log("http请求之后发生错误，会自动执行请求拦截器");
    return Promise.reject(error);
});


// 响应拦截器
http.interceptors.response.use((response)=>{
    console.log("服务端响应数据以后在执行then之前，会自动执行响应拦截器");
    return response;
}, (error)=>{
    console.log("服务端响应错误以后在执行catch之前，会自动执行响应拦截器");
    return Promise.reject(error);
});

export default http;
```

`src/settings/index.js`，代码：

```javascript
const settings = {
    host: "http://api.autocve.cn:8000/",
}

export default settings;
```

从上面效果，可以看到当前客户端已经安装配置好了router路由模块以及axios请求模块，并可以正常使用的。

#### 跨域支持


`src/http/requests.js`，代码：

```javascript
import http from "./index.js";

// 获取站点配置信息
export const get_api_test = (params, headers) => {
    return http.get("test/", {params, headers})
};
```

然后在`views\Host.vue`发送ajax请求：

```vue
<template>
  <div class="host">
    <h1>host页面</h1>
  </div>
</template>

<script setup>
import {get_api_test} from "../http/requests.js";

get_api_test().then(response => {
  console.log("response:::", response)
})

</script>

<style scoped>

</style>

```

遇到跨域请求失败



##### 服务端实现跨域支持

基于gin的官方CORS中间件实现跨域资源共享，`autocve_api/applicaton/middleware/cors.go`，代码：

```go
package middleware

import (
	"github.com/gin-contrib/cors"
	"time"
)

var CORS = cors.New(cors.Config{
	//准许跨域请求网站,多个使用,分开,限制使用*
	AllowOrigins: []string{"*"},
	//准许使用的请求方式
	AllowMethods: []string{"PUT", "PATCH", "POST", "GET", "DELETE"},
	//准许使用的请求表头
	AllowHeaders: []string{"Origin", "Authorization", "Content-Type"},
	//显示的请求表头
	ExposeHeaders: []string{"Content-Type"},
	//凭证共享,确定共享
	AllowCredentials: true,
	//容许跨域的原点网站,可以直接return true就万事大吉了
	AllowOriginFunc: func(origin string) bool {
		return true
	},
	//超时时间设定
	MaxAge: 24 * time.Hour,
})

```

调用中间件，在`autocve_api/application/initialize/router.go`，代码：

```go
Router.Use(middleware.CORS)
```

完成了上面的步骤，我们就可以再访问host，通过后端提供数据给前端使用ajax访问了。



##### 客户端实现跨域支持

在`vue.config.js`中

```js
/* 跨域代理 */
proxy: {
    "/api": {
        /* 目标代理服务器地址 */
        target: "http://api.autocve_api.cn:8080/api", //
        /* 允许跨域 */
        changeOrigin: true,
        ws: true,
        pathRewrite: {
            "^/api": ""   // 　/api表示需要去匹配请求时的url，然后替换成target的值，由node.js发出请求
        }
    }
}
```

## 用户中心

### 用户模型

创建用户模型，测试数据库初始化是否正常使用`/application/model/user.go`，代码：

```go
package model

import (
	. "autocve_api/application/database"
	"gorm.io/gorm"
)

/**
用户实体
*/

type User struct {
	gorm.Model
	Username     string `gorm:"unique_index;size:255;comment:'账户名'" json:"username" sql:"index"`
	HashPassword string `gorm:"not null;size:255;comment:'密码'" json:"-"`
	Password     string `gorm:"-" json:"password,omitempty"`
	Nickname     string `gorm:"size:255;comment:'昵称'" json:"nickname" sql:"index"`
	Mobile       string `gorm:"index;size:15;comment:'手机';" json:"mobile"`
	Email        string `valid:"email" gorm:"index;size:255;comment:'邮箱';" json:"email"`
	Avatar       string `gorm:"size:255;comment:'头像'" json:"avatar"`
	Sex          bool   `gorm:"type:boolean;default:true;comment:'性别'" json:"sex"`
	Ip           string `valid:"ip" gorm:"size:255;comment:'IP地址';" json:"ip"`
	Status       bool   `gorm:"type:boolean;default:true;comment:'状态'" json:"status"`
}


--- 基础方法
/**
设置表名
*/

func (User) TableName() string {
	return "user_info"
}

/**
创建用户
*/

func (user User) Insert() (id uint, err error) {
	//添加数据
	result := Orm.Create(&user)
	return user.ID, result.Error
}

/**
根据指定ID获取用户
*/

func (user *User) GetOneById(id uint) {
	Orm.First(&user, id)
}

/**
根据账户信息(用户名、手机、邮箱)获取用户
*/

func (user *User) GetOneByAccount(account string) {
	Orm.First(&user, "username = ? or mobile = ? or email= ?", account, account, account)
}

/**
获取所有用户
*/

func (user User) GetAll() []User {
	var users []User
	Orm.Find(&users)
	return users
}

/**
更新密码
*/

func (user User) ChangePassword(HashPasswrd string) {
	user.HashPassword = HashPasswrd
	Orm.Save(&user)
}

```

项目初始化并数据迁移，`initialize/db.go`，代码：

```python
package initialize

import (
	"autocve_api/application/config"
	"autocve_api/application/database"
	"autocve_api/application/model"
	"fmt"
)

func InitDB(cfg *config.DatabaseConfig) {
	fmt.Println("hello ...")
	Orm := database.GetOrm(cfg)
	// 禁用复数
	Orm.SingularTable(true)
	// 数据迁移
	Orm.AutoMigrate(&model.User{})
}

```

### 创建账户的API接口

```go
分层
api  --> service 方法 ---> user结构体中的基础方法
```

该接口目前仅用于测试添加超级用户，将来需要补充上权限。

业务层代码，`autocve_api/application/services/user.go`，代码：

```go
package services

import (
	. "autocve_api/application/model"
	. "autocve_api/application/utils"
	"github.com/gin-gonic/gin"
)

/**
创建用户
*/

func CreateUser(ctx *gin.Context) (uint, error) {
	user := User{}
	var err error
	if err = ctx.ShouldBindJSON(&user); err != nil {
		return 0, err
	}

	user.HashPassword, err = MakeHashPassword(user.Password)
	if err != nil {
		return 0, err
	}

	return user.Insert()
}

/**
获取指定ID的用户
*/

func GetUserById(id uint) (user User) {
	user = User{}
	user.GetOneById(id)
	return user
}

/**
根据账户信息(用户名、手机、邮箱)获取用户
*/

func GetUserByAccount(account string) (user User) {
	user = User{}
	user.GetOneByAccount(account)
	return user
}

/**
获取所有用户
*/

func GetAllUser() []User {
	user := User{}
	return user.GetAll()
}

/**
更新密码
*/

func ChangeUserPassword(user User, RawPassword string) {
	password, _ := MakeHashPassword(RawPassword)
	user.ChangePassword(password)
}

```

工具方法，`autocve_api/application/utils/string.go`，代码：

```go
package utils

import (
	. "autocve_api/application/constants"
	"golang.org/x/crypto/bcrypt"
	"math/rand"
	"time"
)

func Random(n int, chars string) string {
	if n <= 0 {
		return ""
	}
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	bytes := make([]byte, n, n)
	l := len(chars)
	for i := 0; i < n; i++ {
		bytes[i] = chars[r.Intn(l)]
	}
	return string(bytes)
}

func RandomLetters(n int) string {
	/**
	生成指定长度的字符串(字母)
	*/
	return Random(n, LETTERS)
}

func RandomNumeric(n int) string {
	/**
	生成指定长度的字符串(数字)
	*/
	return Random(n, NUMBERS)
}

func RandomLettersNumeric(n int) string {
	/**
	生成指定长度的字符串(数字+字母)
	*/
	return Random(n, LETTERS_NUMBERIC)
}

func RandomAscii(n int) string {
	/**
	生成指定长度的字符串(字母+数字+特殊字符)
	*/
	return Random(n, ASCII)
}

/*
 加密密码
*/

func MakeHashPassword(RawPassword string) (HashPasswrd string, err error) {
	pwd := []byte(RawPassword)
	hash, err := bcrypt.GenerateFromPassword(pwd, bcrypt.MinCost)
	if err != nil {
		return
	}
	HashPasswrd = string(hash)
	return
}

/**
验证密码
*/

func CheckPassword(HashPassword string, RawPassword string) bool {
	ByteHash := []byte(HashPassword)
	BytePwd := []byte(RawPassword)
	err := bcrypt.CompareHashAndPassword(ByteHash, BytePwd)
	if err != nil {
		return false
	}
	return true
}

```

常量文件中创建常用字符集合的常量，`autocve_api/application/constants/common.go`，代码：

```go
package constants

/**
常用字符集合
*/

const NUMBERS string = "0123456789"
const LETTERS string = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
const SPECIALS string = "~!@#$%^*()_+-=[]{}|;:,./<>?"
const LETTERS_NUMBERIC string = LETTERS + NUMBERS
const ASCII string = LETTERS_NUMBERIC + SPECIALS

```

接口层，autocve_api/application/api/user.go，代码：

```go
package api

import (
	"autocve_api/application/constants"
	. "autocve_api/application/services"
	"github.com/gin-gonic/gin"
	"net/http"
)

/**
用户认证登陆
*/

func UserAuthenticate(ctx *gin.Context) {
	var data map[string]string = map[string]string{
		"userame": "xiaoming",
		"age":     "16",
	}
	ctx.JSON(http.StatusOK, data)
}

/**
创建用户
*/

func UserCreate(ctx *gin.Context) {

	id, err := CreateUser(ctx)
	if err != nil || id < 1 {
		ctx.JSON(http.StatusOK, gin.H{
			"code":    constants.CodeCreateUserFail,
			"message": constants.CreateUserFail,
		})
		return
	}

	ctx.JSON(http.StatusCreated, gin.H{
		"code":    constants.CodeSuccess,
		"message": constants.CreateUserSuccess,
		"data":    id,
	})
}

```

消息提示常量，`autocve_api/application/constants/message.go`，代码：

```go
package constants

const (
	CreateUserSuccess = "创建用户成功！"
	CreateUserFail    = "创建用户失败！"
)

```

消息ID常量，`autocve_api/application/constants/code.go`，代码：

```go
package constants

const (
	CodeSuccess = 0 // 成功！
	CodeCreateUserFail = 1001  // 创建用户失败！
)
```

路由层，`autocve_api/application/router/user.go`，代码：

```go
package router

import (
	"autocve_api/application/api"
	"autocve_api/application/utils"
	"github.com/gin-gonic/gin"
)

func InitUserRouter(Router *gin.RouterGroup) {
	/**
	用户相关的路由组
	*/
	UserRouter := Router.Group("user")
	{
		// 用户认证登陆
		utils.Register(UserRouter, []string{"GET", "POST"}, "authenticate", api.UserAuthenticate)
		// 用户创建
		utils.Register(UserRouter, []string{"POST"}, "", api.UserCreate)
	}
}

```

`autocve_api/application/utils/router`，

```go
package utils

import "github.com/gin-gonic/gin"

func Register(r *gin.RouterGroup, httpMethods []string, relativePath string, handlers ...gin.HandlerFunc) gin.IRoutes {
	/**
	路由注册函数[一次性给同一个视图绑定多个不同的HTTP请求方法]
	*/
	var routes gin.IRoutes
	for _, httpMethod := range httpMethods {
		routes = r.Handle(httpMethod, relativePath, handlers...)
	}
	return routes
}

```

`autocve_api/application/initialize/router`，

```go
package initialize

import (
	"autocve_api/application/middleware"
	. "autocve_api/application/router"
	"github.com/gin-gonic/gin"
)

func InitRouter() *gin.Engine {

	// 1. 创建路由
	Router := gin.Default()
	Router.Use(middleware.GinLogger())
	Router.Use(middleware.ExceptionMiddleware)
	Router.Use(middleware.CORS)

	// 2. Api路由分组
	ApiGroup := Router.Group("/test")

	ApiGroup.GET("/", func(context *gin.Context) {
		//panic("raise an error!!!")
		context.String(200, "autocve Start")
	})

	InitUserRouter(ApiGroup)

	return Router
}

```

### validator User

接下来，我们肯定是需要验证客户端提交的数据是否合法。因此，我们还需要安装一个插件：validator。validator本身提供了基于struct结构体的tag标签提供了一系列的验证规则和提供了自定义验证规范的方式给我们可以快速的完成客户端数据的校验工作。但是，validator默认返回的错误信息是英文的，因为我们还要翻译下错误信息。

```bash
# 验证模块
go get -u github.com/go-playground/validator/v10
# 翻译模块
go get -u github.com/go-playground/locales/zh
go get -u github.com/go-playground/universal-translator
go get -u github.com/go-playground/validator/v10/translations/zh
```

`model/user.go`代码：

```go
/**
用户实体
*/

type User struct {
	gorm.Model
	Username      string `validate:"required,gte=5" label:"账户名" gorm:"unique_index;size:255;comment:'账户名'" json:"username"`
	HashPassword  string `gorm:"not null;size:255;comment:'密码'" json:"-"`
	Password      string `validate:"required" label:"登陆密码" gorm:"-" json:"password,omitempty"`
	Nickname      string `label:"昵称" gorm:"size:255;comment:'昵称'" json:"nickname" sql:"index"`
	Mobile        string `gorm:"index;size:15;comment:'手机';" json:"mobile"`
	Email         string `validate:"omitempty,email" gorm:"index;size:255;comment:'邮箱';" json:"email"`
	Avatar        string `gorm:"size:255;comment:'头像'" json:"avatar"`
	Sex           bool   `gorm:"type:boolean;default:true;comment:'性别'" json:"sex"`
	Ip            string `validate:"omitempty,ipv4" gorm:"size:255;comment:'IP地址';" json:"ip"`
	Status        bool   `gorm:"type:boolean;default:true;comment:'状态'" json:"status"`
}
```

`autocve_api/application/utils/vaidator.go`，代码：

```go
package utils

import (
	"github.com/go-playground/locales/zh"
	ut "github.com/go-playground/universal-translator"
	"github.com/go-playground/validator/v10"
	. "github.com/go-playground/validator/v10/translations/zh"
	"reflect"
)

/**
生成验证器
*/

func GenValidate() (*validator.Validate, ut.Translator) {
	zhCh := zh.New()
	validate := validator.New()
	//注册一个函数，获取struct tag里自定义的label作为字段名
	validate.RegisterTagNameFunc(func(fld reflect.StructField) string {
		name := fld.Tag.Get("label")
		return name
	})

	UniversalTranslator := ut.New(zhCh)
	trans, _ := UniversalTranslator.GetTranslator("zh")
	_ = RegisterDefaultTranslations(validate, trans)
	return validate, trans
}

```

`application/validator/user.go`，代码：

```go
package validator

import (
	. "autocve_api/application/model"
	. "autocve_api/application/utils"
	"errors"
	"github.com/go-playground/validator/v10"
)

/**
登录验证器
*/

func UserValidator(user *User) error {
	validate, trans := GenValidate()
	err := validate.Struct(user)
	if err != nil {
		for _, err := range err.(validator.ValidationErrors) {
			return errors.New(err.Translate(trans))
		}
	}
	return nil
}

```

`services/user.go`，代码：

```go
package services

import (
	"autocve_api/application/constants"
	. "autocve_api/application/model"
	. "autocve_api/application/utils"
	"autocve_api/application/validator"
	"errors"
	"fmt"
	"github.com/gin-gonic/gin"
)

/**
用户登录认证
*/

func UserLogin(ctx *gin.Context) (user User, err error) {
	user = User{}
	if err = ctx.ShouldBindJSON(&user); err != nil {
		return user, err
	}

	// 校验输入字段
	if err = validator.UserValidator(&user); err != nil {
		return user, err
	}

	user.GetOneByAccount(user.Username)
	if user.ID < 1 {
		return user, errors.New(constants.NoSuchUser)
	}

	ret := CheckPassword(user.HashPassword, user.Password)

	if !ret {
		err = errors.New(constants.PasswordError)
		return
	}

	return
}

/**
创建用户
*/

func CreateUser(ctx *gin.Context) (uint, error) {
	user := User{}
	var err error
	if err = ctx.ShouldBindJSON(&user); err != nil {
		return 0, err
	}

	// 校验输入字段
	if err = validator.UserValidator(&user); err != nil {
		fmt.Println("err:::", err)
		return 0, err
	}

	user.HashPassword, err = MakeHashPassword(user.Password)
	if err != nil {
		return 0, err
	}

	return user.Insert()
}

/**
获取指定ID的用户
*/

func GetUserById(id uint) (user User) {
	user = User{}
	user.GetOneById(id)
	return user
}

/**
根据账户信息(用户名、手机、邮箱)获取用户
*/

func GetUserByAccount(account string) (user User) {
	user = User{}
	user.GetOneByAccount(account)
	return user
}

/**
获取所有用户
*/

func GetAllUser() []User {
	user := User{}
	return user.GetAll()
}

/**
更新密码
*/

func ChangeUserPassword(user User, RawPassword string) {
	password, _ := MakeHashPassword(RawPassword)
	user.ChangePassword(password)
}

```

`api/user.go`，代码：

```go
package api

import (
	"autocve_api/application/constants"
	. "autocve_api/application/services"
	"github.com/gin-gonic/gin"
	"net/http"
)

/**
用户认证登陆
*/

func UserAuthenticate(ctx *gin.Context) {
	user, err := UserLogin(ctx)

	if err != nil || user.ID < 1 {
		ctx.JSON(http.StatusOK, gin.H{
			"code":    constants.CodeNoSuchUser,
			"message": err.Error(),
		})
		return
	}

	ctx.JSON(http.StatusCreated, gin.H{
		"code":    constants.CodeSuccess,
		"message": constants.Success,
		"data":    user,
	})
}

/**
创建用户
*/

func UserCreate(ctx *gin.Context) {

	id, err := CreateUser(ctx)

	if err != nil || id < 1 {
		ctx.JSON(http.StatusOK, gin.H{
			"code":    constants.CodeCreateUserFail,
			"message": constants.CreateUserFail + err.Error(),
		})
		return
	}

	ctx.JSON(http.StatusCreated, gin.H{
		"code":    constants.CodeSuccess,
		"message": constants.CreateUserSuccess,
		"data":    id,
	})
}

```

`constants/message.go`，代码：

```go
package constants

const (
	Success           = "成功！"
	CreateUserFail    = "创建用户失败！"
	CreateUserSuccess = "创建用户成功！"
	NoSuchUser        = "用户不存在！"
	PasswordError     = "密码错误！"
)


```

`constants/code.go`，代码：

```go
package constants

const (
	CodeSuccess = 0 // 成功！
	CodeCreateUserFail = 1001  // 创建用户失败！
	CodeNoSuchUser = 1002  // 当前用户不存在！
)

```



### JWT

在用户注册或登录后，我们想记录用户的登录状态，或者为用户创建身份认证的凭证。我们使用Json Web Token认证机制。

很多公司开发的一些移动端可能不支持cookie，并且我们通过cookie和session做接口登录认证的话，效率其实并不是很高，我们的接口可能提供给多个客户端，session数据保存在服务端，那么就需要每次都调用session数据进行验证，比较耗时，所以引入了token认证的概念，我们可以通过jwt来完成原来cookie或者session的认证效果，接下来看看jwt是怎么实现的。

> Json web token (JWT), 是为了在网络应用环境间传递声明(token，一段字符串)而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明(token，一段字符串)一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于身份认证，也可被数据加密。



JWT就一段字符串，由三段信息构成的，将这三段信息文本用`.`拼接一起就构成了Jwt字符串。就像这样：

```htaccess
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

第一部分我们称它为头部（header)，第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).

**header**

jwt的头部承载两部分信息：

- 声明token类型，这里是jwt，除了jwt就是Bearer
- 声明签名加密的算法 通常直接使用 HMAC SHA256

完整的头部就像下面这样的JSON/map： 

```
map[string]string{
  "typ": "JWT",
  "alg": "HS256"
}
```

然后将头部进行base64.StdEncoding.EncodeToString编码，构成了第一部分.

```htaccess
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

Test:

```golang
package main

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
)

func main() {
	// 头部信息
	headerData := map[string]string{
		"typ": "JWT",
		"alg": "HS256",
	}

	headerJson, _ := json.Marshal(headerData)
	headerBytes := []byte(string(headerJson))
	// base64编码
	headerString := strings.TrimRight(base64.URLEncoding.EncodeToString(headerBytes), "=")
	fmt.Println(headerString)

	// base64解码
	headerBytes, _ = base64.URLEncoding.DecodeString(headerString)
	fmt.Println(string(headerBytes)) // {"alg":"HS256","typ":"JWT"}

	type Header struct {
		Alg string `json:"alg"`
		Typ string `json:"typ"`
	}

	header := Header{}
	json.Unmarshal([]byte(headerBytes), &header)
	fmt.Printf("%#v", header)
}

// 各个语言中都有base64编码和解码的功能，所以我们jwt为了安全，需要配合第三段签证加密

```

**payload**

载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息可以存放下面三个部分信息。

> - 标准声明（注册声明、预定义声明，registered claims）
> - 公共声明（public claims）
> - 私有声明（private claims）

**标准声明** (官方规范，是建议但不强制使用) ：

> - **iss**: jwt签发者
>
> - **sub**: jwt所面向的用户
>
> - **aud**: 接收jwt的一方
>
> - **exp**: jwt的过期时间，这个过期时间必须要大于签发时间
>
> - **nbf**: 定义在什么时间之前，该jwt都是不可用的.
>
> - **iat**: jwt的签发时间
>
> - **jti**: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。
>
>   以上是JWT 规定的7个官方字段，供选用

**公共声明** ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端直接可以查看.

**私有声明** ： 私有声明是服务端和客户端所共同定义的声明，一般使用了ace算法进行对称加密和解密的，意味着该部分信息可以归类为明文信息。

定义一个payload，json格式的数据:

```go
map[string]string{
    "sub":   "1234567890",
		"exp":   "3422335555",
		"name":  "yuan",
		"admin": "1",
		"info":  "123abc456",
}
```

然后将其进行base64.StdEncoding.EncodeToString编码，得到JWT的第二部分。

```htaccess
eyJhZG1pbiI6IjEiLCJleHAiOiIzNDIyMzM1NTU1IiwiaW5mbyI6IjEyM2FiYzQ1NiIsIm5hbWUiOiJ5dWFuIiwic3ViIjoiMTIzNDU2Nzg5MCJ9
```

```go
package main

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
)

func main() {

	payloadData := map[string]string{
		"sub":   "1234567890",
		"exp":   "3422335555",
		"name":  "yuan",
		"admin": "1",
		"info":  "123abc456",
	}
	payloadBytes, _ := json.Marshal(payloadData)

	// base64编码
	payloadString := strings.TrimRight(base64.URLEncoding.EncodeToString(payloadBytes), "=")
	fmt.Println(payloadString)

	// base64解码
	payloadBytes, _ = base64.URLEncoding.DecodeString(payloadString)
	fmt.Println(string(payloadBytes))

	type Payload struct {
		Sub   string `json:"sub"`
		Exp   string `json:"exp"`
		Name  string `json:"name"`
		Admin string `json:"admin"`
		Info  string `json:"info"`
	}

	payload := Payload{}
	json.Unmarshal([]byte(payloadBytes), &payload)
	fmt.Printf("%#v", payload)

}

```

**signature**

JWT的第三部分是一个签证信息，这个签证信息由三部分组成：

- header (base64编码后的)
- payload (base64编码后的)
- secret 密钥

这个部分需要base64加密后的header和base64加密后的payload使用`.`连接组成的字符串，然后通过header中声明的加密算法进行加盐`secret`组合加密，然后就构成了jwt的第三部分。

```go
package main

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"strings"
)

func main() {

	// 头部
	header := map[string]string{
		"typ": "JWT",
		"alg": "HS256",
	}
	ret, _ := json.Marshal(header)
	headerString := base64.URLEncoding.EncodeToString(ret)
	fmt.Println(headerString)

	// 载荷
	payload := map[string]string{
		"sub":   "1234567890",
		"exp":   "3422335555",
		"name":  "yuan",
		"admin": "1",
		"info":  "123abc456",
	}
	ret, _ = json.Marshal(payload)

	// base64编码
	payloadString := strings.TrimRight(base64.URLEncoding.EncodeToString(ret), "=")
	fmt.Println(payloadString)

	// 签证
	// HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
	secret := "secret"
	sign := fmt.Sprintf("%s.%s", headerString, payloadString)
	key := []byte(secret)
	h := hmac.New(sha256.New, key)
	h.Write([]byte(sign))
	signature := hex.EncodeToString(h.Sum(nil))

	fmt.Printf("%s.%s.%s", headerString, payloadString, signature)
}

```

将这三部分用`.`连接成一个完整的字符串,构成了最终的jwt:

```htaccess
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6IjEiLCJleHAiOiIzNDIyMzM1NTU1IiwiaW5mbyI6IjEyM2FiYzQ1NiIsIm5hbWUiOiJ5dWFuIiwic3ViIjoiMTIzNDU2Nzg5MCJ9.d7346bb5a519703477f400fc5e2eb5c341c79acce75b699f0aed0cbaf0e2fcfb
```

**注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。**

```gfm
jwt的优点：
1. 实现分布式的单点登陆非常方便
2. 数据实际保存在客户端，所以我们可以分担服务端的存储压力
3. JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。

jwt的缺点：
1. 数据保存在了客户端，我们服务端只认jwt，不识别客户端。
2. jwt可以设置过期时间，但是因为数据保存在了客户端，所以对于过期时间不好调整。
3. 因为jwt发放以后保存在了客户端，而且验证过程中并没有到数据库查验用户的状态，所以会出现用户被删除了/被拉黑，依然可以通过token访问进来。

# secret_key轻易不要改，一改所有客户端都要重新登录
```

### Go-JWT

#### go-jwt的基本功能测试

**关于签发和核验JWT，我们可以使用go-jwt包来完成。**

```bash
go get -u github.com/dgrijalva/jwt-go
```

`Test/jwt/main.go`，测试代码，代码：

```go
package main

import (
	"errors"
	"fmt"
	"github.com/dgrijalva/jwt-go"
	"time"
)

// 消息提示常量
const (
	TokenExpired     = "认证令牌过期！"
	TokenNotValidYet = "令牌尚未激活！"
	TokenMalformed   = "认证令牌格式有误！"
	TokenInvalid     = "无效的认证令牌！"
)

// SecretKey 秘钥
var (
	SecretKey string = "secret"
)

/**
JWT
*/

type JWT struct {
	SigningKey []byte
}

/**
载荷
*/

type PublicClaims struct {
	ID       string `json:"id"`
	Username string `json:"username"`
	jwt.StandardClaims
}

/**
新建一个jwt实例
*/

func NewJWT() *JWT {
	return &JWT{
		[]byte(GetSecretKey()),
	}
}

/**
获取SecretKey
*/

func GetSecretKey() string {
	return SecretKey
}

/**
生成一个AccessToken
*/

func (j *JWT) AccessToken(claims PublicClaims) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(j.SigningKey)
}

/**
从Token中提取载荷
*/

func (j *JWT) GetPayloadByToken(tokenString string) (*PublicClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &PublicClaims{}, func(token *jwt.Token) (interface{}, error) {
		return j.SigningKey, nil
	})
	if err != nil {
		if ve, ok := err.(*jwt.ValidationError); ok {
			if ve.Errors&jwt.ValidationErrorMalformed != 0 {
				return nil, errors.New(TokenMalformed)
			} else if ve.Errors&jwt.ValidationErrorExpired != 0 {
				return nil, errors.New(TokenExpired)
			} else if ve.Errors&jwt.ValidationErrorNotValidYet != 0 {
				return nil, errors.New(TokenNotValidYet)
			} else {
				return nil, errors.New(TokenInvalid)
			}
		}
	}
	if claims, ok := token.Claims.(*PublicClaims); ok && token.Valid {
		return claims, nil
	}
	return nil, errors.New(TokenInvalid)
}

/**
更新token
*/

func (j *JWT) RefreshToken(tokenString string) (string, error) {
	jwt.TimeFunc = func() time.Time {
		return time.Unix(0, 0)
	}
	token, err := jwt.ParseWithClaims(tokenString, &PublicClaims{}, func(token *jwt.Token) (interface{}, error) {
		return j.SigningKey, nil
	})
	if err != nil {
		return "", err
	}
	if claims, ok := token.Claims.(*PublicClaims); ok && token.Valid {
		jwt.TimeFunc = time.Now
		println(time.Now().Add(1 * time.Hour).Unix())
		claims.StandardClaims.ExpiresAt = time.Now().Add(1 * time.Hour).Unix()
		return j.AccessToken(*claims)
	}
	return "", errors.New(TokenInvalid)
}

func main() {
	publicClaims := PublicClaims{
		ID:       "1",
		Username: "yuan",
	}
	newJwt := NewJWT()
	token, _ := newJwt.AccessToken(publicClaims)
	println(token)

	refreshToken, _ := newJwt.RefreshToken(token)
	fmt.Println("refresh token:", refreshToken)

}

```

接下来，把jwt集成到项目中即可在用户注册或登录成功后，返回token即可。

#### 基于go-jwt的jwt包封装

新增配置项，把秘钥设置为配置信息，`autocve_api/application/config/config.go`，代码：

```go
package config

import (
	"encoding/json"
	"github.com/dgrijalva/jwt-go"
	"io/ioutil"
)

// ... 代码省略
// ... 代码省略
// ... 代码省略

// Config 整个项目的配置
type Config struct {
	Mode                string `json:"mode"`
	Port                int    `json:"port"`
	SecretKey           string `json:"secret_key"`
	*LogConfig          `json:"log"`
	*DatabaseConfig     `json:"database"`
	*jwt.StandardClaims `json:"jwt"`
}
// ... 代码省略
// ... 代码省略
// ... 代码省略

```

`autocve_api/application/config.json`，代码：

```json
{
  "mode": "debug",
  "port": 8000,
  // 代码省略...
  "secret_key": "Ub=~sV,U1QXmvHObh_My6#6-O9>}zK{8",
  "jwt": {
    "exp": 1800
  }
}

```

`autocve_api/application/utils/jwt.go`，代码：

```go
package utils

import (
	"errors"
	"github.com/dgrijalva/jwt-go"
	"time"
	"autocve_api/application/config"
	. "autocve_api/application/constants"
)


/**
JWT基本结构体
*/

type JWT struct {
	SigningKey []byte
}


/**
 载荷
 */

type PublicClaims struct {
	ID         string `json:"id"`
	Username   string `json:"username"`
	Nickname   string `json:"nickname"`
	Avatar     string `json:"avatar"`
	jwt.StandardClaims
}


/**
新建一个jwt实例
*/

func NewJWT() *JWT {
	return &JWT{
		[]byte(config.Conf.SecretKey),
	}
}


/**
生成一个AccessToken
*/

func (j *JWT) AccessToken(claims PublicClaims) (string, error) {
	// 获取当前时间
	now := time.Now()
	// 获取当前时间的Unix时间戳
	nowAt := now.Unix()
	// 设置token的签发时间
	claims.IssuedAt = nowAt
	// 设置jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。
	claims.Id = uuid4()
	// 判断：如果配置项中有设置token的过期时间
	if config.Conf.ExpiresAt > 0 {
		// 则在token的载荷信息中记录，当前token的起用时间和过期时间
		expAt := now.Add(time.Duration(config.Conf.ExpiresAt) * time.Second).Unix()
		claims.ExpiresAt = expAt
		claims.NotBefore = nowAt
	}
	// 判断：如果配置中有设置token的起用时间
	if config.Conf.NotBefore > 0 {
		// 则在token的载荷信息中记录，当前token的起用时间
		nbfAt := now.Add(time.Duration(config.Conf.NotBefore) * time.Second).Unix()
		claims.NotBefore = nbfAt
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(j.SigningKey)
}


/**
从Token中提取载荷
*/

func (j *JWT) GetPayloadByToken(tokenString string) (*PublicClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &PublicClaims{}, func(token *jwt.Token) (interface{}, error) {
		return j.SigningKey, nil
	})
	if err != nil {
		if ve, ok := err.(*jwt.ValidationError); ok {
			if ve.Errors&jwt.ValidationErrorMalformed != 0 {
				return nil, errors.New(TokenIsMalformed)
			} else if ve.Errors&jwt.ValidationErrorExpired != 0 {
				return nil, errors.New(TokenIsExpired)
			} else if ve.Errors&jwt.ValidationErrorNotValidYet != 0 {
				return nil, errors.New(TokenIsNotValidYet)
			} else {
				return nil, errors.New(TokenIsInvalid)
			}
		}
	}
	if claims, ok := token.Claims.(*PublicClaims); ok && token.Valid {
		return claims, nil
	}
	return nil, errors.New(TokenIsInvalid)
}


/**
更新token
*/

func (j *JWT) RefreshToken(tokenString string) (string, error) {
	jwt.TimeFunc = func() time.Time {
		return time.Unix(0, 0)
	}
	token, err := jwt.ParseWithClaims(tokenString, &PublicClaims{}, func(token *jwt.Token) (interface{}, error) {
		return j.SigningKey, nil
	})
	if err != nil {
		return "", err
	}
	if claims, ok := token.Claims.(*PublicClaims); ok && token.Valid {
		jwt.TimeFunc = time.Now
		println(time.Now().Add(1 * time.Hour).Unix())
		claims.StandardClaims.ExpiresAt = time.Now().Add(1 * time.Hour).Unix()
		return j.AccessToken(*claims)
	}
	return "", errors.New(TokenIsInvalid)
}

```

声明错误提示的常量，`autocve_api/application/constants/message.go`，代码：

```go
package constants

const (
	Success           = "成功！"
	CreateUserFail    = "创建用户失败！"
	CreateUserSuccess = "创建用户成功！"
	NoSuchUser        = "用户不存在！"
	PasswordError     = "密码错误！"

	TokenIsExpired     = "认证令牌过期！"
	TokenIsNotValidYet = "令牌尚未激活！"
	TokenIsMalformed   = "认证令牌格式有误！"
	TokenIsInvalid     = "无效的认证令牌！"
)

```

`autocve_api/application/constants/code.go`，代码：

```go
package constants

const (
	CodeSuccess        = 0    // 成功！
	CodeFail           = -1   // 失败！
	CodeAuthticateFail = -2   // 认证失败！
	CodeCreateUserFail = 1001 // 创建用户失败！
	CodeNoSuchUser     = 1002 // 当前用户不存在
)
```

声明一个辅助函数，用于生成UUID格式字符串，提供给jwt的载荷。

```bash
go get -u github.com/satori/go.uuid
```

`autocve_api/application/utils/string.go`，代码：

```go
package utils

import (
	"fmt"
	uuid "github.com/satori/go.uuid"
	"golang.org/x/crypto/bcrypt"
	"math/rand"
	"time"
	. "autocve_api/application/constants"
)

// 代码省略...
// 代码省略...
// 代码省略...

/**
 生成UUID4
 */

func uuid4() string {
	return fmt.Sprintf("%s", uuid.NewV4())
}
```

**生成token接口测试**

`services/user.go`

```go
func UserLogin(ctx *gin.Context) (user User, err error) {
	user = User{}
	if err = ctx.ShouldBindJSON(&user); err != nil {
		return user, err
	}

	if err = validator.UserValidator(&user); err != nil {
		return user, err
	}

	user.GetOneByAccount(user.Username)
	if user.ID < 1 {
		return user, errors.New(constants.NoSuchUser)
	}

	ret := CheckPassword(user.HashPassword, user.Password)

	if !ret {
		err = errors.New(constants.PasswordError)
		return
	}

	return
}
```

`autocve_api/application/api/user.go`，代码：

```go
package api

import (
	"github.com/gin-gonic/gin"
	"net/http"
	"strconv"
	"autocve_api/application/constants"
	. "autocve_api/application/services"
	. "autocve_api/application/utils"
)


/**
用户认证登陆
*/

func UserAuthenticate(ctx *gin.Context){

	// 用户登陆认证业务
	user, err := UserLogin(ctx)

	if err != nil || user.ID < 1 {
		ctx.JSON(http.StatusOK, gin.H{
			"code":    constants.CodeNoSuchUser,
			"message": constants.NoSuchUser+err.Error(),
		})
		return
	}

	// 生成token
	newJwt := NewJWT()
	publicClaims := PublicClaims {
		ID: strconv.Itoa(int(user.ID)),
		Username: user.Username,
		Nickname: user.Nickname,
		Avatar  : user.Avatar,
	}

	token, err := newJwt.AccessToken(publicClaims)
	if err != nil {
		panic(err.Error())
	}

	ctx.JSON(http.StatusCreated, gin.H{
		"code": constants.CodeSuccess,
		"message": constants.Success,
		"data": map[string]interface{}{
			"token": token,
		},
	})
}


// 代码省略...
// 代码省略...
// 代码省略...
```



**验证token**

声明中间件用于验证JWT token 的合法性（有效期、格式）。

`autocve_api/application/middleware/jwt.go`，代码：

```go
package middleware

import (
"github.com/gin-gonic/gin"
"go.uber.org/zap"
"net/http"
"autocve_api/application/constants"
. "autocve_api/application/utils"
)

// JWTAuthorization 验证token
func JWTAuthorization() gin.HandlerFunc {
	return func(c *gin.Context) {
		token := c.Request.Header.Get("Authorization")
		if token == "" {
			c.JSON(http.StatusOK, gin.H{
				"code": constants.CodeAuthticateFail,
				"message": constants.TokenIsInvalid,
			})
			c.Abort()
			return
		}

		zap.S().Debugf("get token: %#v", token)

		j := NewJWT()
		// parseToken 解析token包含的信息
		claims, err := j.GetPayloadByToken(token)
		if err != nil {
			c.JSON(http.StatusOK, gin.H{
				"code": constants.CodeAuthticateFail,
				"message": err.Error(),
			})
			c.Abort()
			return
		}

		// 存储认证的载荷信息和token，保留至后面使用。
		c.Set("claims", claims)
		c.Set("access_token", token)
		c.Next()
	}
}

```

测试，给之前声明的创建用户的接口，加上token验证中间件。

在 `initialize/router.go`中设置jwt验证中间件

```go
// 注册中间件
Router.Use(middleware.JWTAuthorization(), middleware.GinLogger(), middleware.GinRecovery(true))
```

> 这是全局中间件，像登录这样的请求不可能有token的，所以不要设置全局

比如我们给创建用户时添加token验证，在autocve_api/application/router/user.go，代码：

```go
package router

import (
	"github.com/gin-gonic/gin"
	"autocve_api/application/middleware"
	"autocve_api/application/utils"

	"autocve_api/application/api"
)

func InitUserRouter(Router *gin.RouterGroup) {
	/**
	用户相关的路由组
	*/
	UserRouter := Router.Group("user")
  // UserRouter.Use(middleware.JWTAuthorization())
	{
		// 用户认证登陆
		utils.Register(UserRouter, []string{"GET", "POST"}, "authenticate", api.UserAuthenticate)
		// 用户创建
		// utils.Register(UserRouter, []string{"POST"}, "", api.UserCreate)
		utils.Register(UserRouter, []string{"POST"}, "", middleware.JWTAuthorization(), api.UserCreate)
	}

}

```

通过postman测试，可以发现，Token认证中间件正常工作。



### token本地存储

如果要在项目中使用axios进行ajax请求，肯定需要在新建一个axios的初始化脚本文件`src/utils/http.js`中进行初始化配置。

axios的初始化配置一般包括以下3部分：

1.  创建axios请求实例对象
2.  配置baseURL设置整个站点ajax请求的api服务端站点公共地址
3.  配置axios请求拦截器和响应拦截器。

`src/utils/http.js`，代码：

```js
import axios from "axios"

const http = axios.create({
    // timeout: 2500,                          // 请求超时，有大文件上传需要关闭这个配置
    baseURL: "http://api.autocve.cn:8080/api",     // 设置api服务端的默认地址[如果基于服务端实现的跨域，这里可以填写api服务端的地址，如果基于nodejs客户端测试服务器实现的跨域，则这里不能填写api服务端地址]
    withCredentials: false,                    // 是否允许客户端ajax请求时携带cookie
})

// 请求拦截器
http.interceptors.request.use((config) => {
    console.log("http请求之前");
    return config;
}, (error) => {
    console.log("http请求错误");
    return Promise.reject(error);
});

// 响应拦截器
http.interceptors.response.use((response) => {
    console.log("服务端响应数据成功以后，返回结果给客户端的第一时间，执行then之前");
    if (response.data.code === -2) {
        router.push("/login")
    }
    return response;
}, (error) => {
    console.log("服务端响应错误内容的时候。...");
    return Promise.reject(error);
});

export default http;
```

`Login.vue`

```vue
<template>
  <div class="login box">
    <img src="../assets/login.jpg" alt="">
    <div class="login">
      <div class="login-title">
        <p class="hi">Hello,autocve!</p>
      </div>
      <div class="login_box">
        <div class="title">
          <span>登录</span>
        </div>
        <div class="inp">
          <a-input v-model:value="user.account" type="text" placeholder="用户名" class="user"></a-input>
          <a-input v-model:value="user.password" type="password" class="pwd" placeholder="密码"></a-input>
          <div class="rember">
            <p>
              <a-checkbox v-model:checked="user.remember">记住密码</a-checkbox>
            </p>
          </div>
          <button class="login_btn" @click="loginHandler">登录</button>

        </div>

      </div>
    </div>
  </div>
</template>

<script setup>
import http from "../http"
import {reactive} from "vue"
import {message} from 'ant-design-vue';
import router from '../router/index.js'


const user = reactive({
  account: "",  // 登录账号/手机号/邮箱
  password: "", // 登录密码
  remember: false, // 是否记住登录状态
  login() {
    // 用户登录
    return http.post("/user/authenticate", {
      "username": this.account,
      "password": this.password,
    })
  }
})

const loginHandler = () => {
  user.login().then((response) => {
    // 先清空原有的token
    localStorage.removeItem("token");
    sessionStorage.removeItem("token");

    if (response.data.code === 0) {
      if (user.remember) {
        // 记住登录
        localStorage.token = response.data.data.token;
      } else {
        sessionStorage.token = response.data.data.token;
      }
      // 跳转到首页

      message.success({
        duration: 0.8,
        content: `登录成功！`,
        onClose() {
          router.push("/autocve/")
        }
      })
    } else {
      message.error('用户名或者密码有误，请重新输入！');
    }

  })
}

</script>

<style scoped>
.login .hi {
  font-size: 20px;
  font-family: "Times New Roman";
  font-style: italic;
}

.box {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

.box img {
  width: 100%;
  min-height: 100%;
}

.box .login {
  position: absolute;
  width: 500px;
  height: 400px;
  left: 0;
  margin: auto;
  right: 0;
  bottom: 0;
  top: -338px;
}

.login .login-title {
  width: 100%;
  text-align: center;
}

.login-title img {
  width: 190px;
  height: auto;
}

.login-title p {
  font-size: 18px;
  color: #fff;
  letter-spacing: .29px;
  padding-top: 10px;
  padding-bottom: 50px;
}

.login_box {
  width: 400px;
  height: auto;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .5);
  border-radius: 4px;
  margin: 0 auto;
  padding-bottom: 40px;
}

.login_box .title {
  font-size: 20px;
  color: #9b9b9b;
  letter-spacing: .32px;
  border-bottom: 1px solid #e6e6e6;
  display: flex;
  justify-content: space-around;
  padding: 50px 60px 0 60px;
  margin-bottom: 20px;
  cursor: pointer;
}

.login_box .title span:nth-of-type(1) {
  color: #4a4a4a;
  border-bottom: 2px solid #396fcc;
}

.inp {
  width: 350px;
  margin: 0 auto;
}

.inp input {
  outline: 0;
  width: 100%;
  height: 45px;
  border-radius: 4px;
  border: 1px solid #d9d9d9;
  text-indent: 20px;
  font-size: 14px;
  background: #fff !important;
}

.inp input.user {
  margin-bottom: 16px;
}

.inp .rember {
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
  margin-top: 10px;
}

.inp .rember p:first-of-type {
  font-size: 12px;
  color: #4a4a4a;
  letter-spacing: .19px;
  margin-left: 22px;
  display: -ms-flexbox;
  display: flex;
  -ms-flex-align: center;
  align-items: center;
  /*position: relative;*/
}

.inp .rember p:nth-of-type(2) {
  font-size: 14px;
  color: #9b9b9b;
  letter-spacing: .19px;
  cursor: pointer;
}

.inp .rember input {
  outline: 0;
  width: 30px;
  height: 45px;
  border-radius: 4px;
  border: 1px solid #d9d9d9;
  text-indent: 20px;
  font-size: 14px;
  background: #fff !important;
}

.inp .rember p span {
  display: inline-block;
  font-size: 12px;
  width: 100px;
  /*position: absolute;*/
  /*left: 20px;*/

}

#geetest {
  margin-top: 20px;
}

.login_btn {
  width: 100%;
  height: 45px;
  background: #396fcc;
  border-radius: 5px;
  font-size: 16px;
  color: #fff;
  letter-spacing: .26px;
  margin-top: 30px;
}

.inp .go_login {
  text-align: center;
  font-size: 14px;
  color: #9b9b9b;
  letter-spacing: .26px;
  padding-top: 20px;
}

.inp .go_login span {
  color: #84cc39;
  cursor: pointer;
}
</style>
```

### 封装token管理文件

一般情况下，我们会在js文件中存放一些需要在多个界面中进行共享的信息。比如用户的登录状态、用户名称、头像、地理位置信息、商品的收藏、购物车中的物品等，这些状态信息，我们可以放在统一的地方，对它进行保存和管理。

在`src/utils`中创建storage.js文件

````js
const storage = {
    state: {
        user: {},
        token: "",
        remember: false
    },
    getUserInfo() {
        console.log("this.state.token:::",this.state)
        if (this.state.token === "") {
            return false
        }
        let payload = this.state.token.split(".")[1]  // 载荷
        let payload_data = JSON.parse(atob(payload)) // 用户信息
        console.log("payload_data:::", payload_data)
        // 从jwt的载荷中提取用户信息
        let now = parseInt((new Date() - 0) / 1000);
        if (payload_data.exp === undefined) {
            // 没登录
            this.clearStorage()
            return {}
        }

        if (parseInt(payload_data.exp) < now) {
            // 过期处理
            this.clearStorage()
            return {}
        }
        return payload_data;
    },
    tokenHandle(token) {
        this.state.token = token;
        // 解析token，获取用户载荷
        this.state.user = this.getUserInfo()
        // 同步本地存储
        this.setStorage()

    },
    key: 'login',
    setStorage() {
        if (this.state.remember) {
            localStorage[this.key] = JSON.stringify(this.state)
        } else {
            sessionStorage[this.key] = JSON.stringify(this.state)
        }
    },
    getStorage() {

        if (localStorage[this.key] === undefined && sessionStorage[this.key] === undefined) {
            return {}
        }

        if (localStorage[this.key]) {
            this.state = JSON.parse(localStorage[this.key])
        } else {
            this.state = JSON.parse(sessionStorage[this.key])
        }
    },
    clearStorage() {

        this.state = {
            user: {},
            token: "",
            remember: false
        }
        localStorage.removeItem(this.key)
        sessionStorage.removeItem(this.key)

    }

}


export default storage
````

`Login.vue`中调用storage.js中的方法管理token

```vue
<template>
  <div class="login box">
    <img src="../assets/login.jpg" alt="">
    <div class="login">
      <div class="login-title">
        <p class="hi">Hello,autocve!</p>
      </div>
      <div class="login_box">
        <div class="title">
          <span>登录</span>
        </div>
        <div class="inp">
          <a-input v-model:value="user.account" type="text" placeholder="用户名" class="user"></a-input>
          <a-input v-model:value="user.password" type="password" class="pwd" placeholder="密码"></a-input>
          <div class="rember">
            <p>
              <a-checkbox v-model:checked="user.remember">记住密码</a-checkbox>
            </p>
          </div>
          <button class="login_btn" @click="loginHandler">登录</button>

        </div>

      </div>
    </div>
  </div>
</template>

<script setup>
import http from "../utils/http"
import {reactive} from "vue"
import {message} from 'ant-design-vue';
import router from '@/router/index.js'
import storage from '@/utils/storage.js'


const user = reactive({
  account: "",  // 登录账号/手机号/邮箱
  password: "", // 登录密码
  remember: false, // 是否记住登录状态
  login() {
    // 用户登录
    return http.post("/user/authenticate", {
      "username": this.account,
      "password": this.password,
    })
  }
})

const loginHandler = () => {
  user.login().then((response) => {
    
    if (response.data.code === 0) {
      // vuex存储用户登录信息，保存token
      storage.tokenHandle(response.data.data.token)

      // 跳转到首页
      message.success({
        duration: 0.8,
        content: `登录成功！`,
        onClose() {
          router.push("/autocve/")
        }
      })
    } else {
      message.error('用户名或者密码有误，请重新输入！');
    }

  })
}

</script>

<style scoped>
.login .hi {
  font-size: 20px;
  font-family: "Times New Roman";
  font-style: italic;
}

.box {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

.box img {
  width: 100%;
  min-height: 100%;
}

.box .login {
  position: absolute;
  width: 500px;
  height: 400px;
  left: 0;
  margin: auto;
  right: 0;
  bottom: 0;
  top: -338px;
}

.login .login-title {
  width: 100%;
  text-align: center;
}

.login-title img {
  width: 190px;
  height: auto;
}

.login-title p {
  font-size: 18px;
  color: #fff;
  letter-spacing: .29px;
  padding-top: 10px;
  padding-bottom: 50px;
}

.login_box {
  width: 400px;
  height: auto;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .5);
  border-radius: 4px;
  margin: 0 auto;
  padding-bottom: 40px;
}

.login_box .title {
  font-size: 20px;
  color: #9b9b9b;
  letter-spacing: .32px;
  border-bottom: 1px solid #e6e6e6;
  display: flex;
  justify-content: space-around;
  padding: 50px 60px 0 60px;
  margin-bottom: 20px;
  cursor: pointer;
}

.login_box .title span:nth-of-type(1) {
  color: #4a4a4a;
  border-bottom: 2px solid #396fcc;
}

.inp {
  width: 350px;
  margin: 0 auto;
}

.inp input {
  outline: 0;
  width: 100%;
  height: 45px;
  border-radius: 4px;
  border: 1px solid #d9d9d9;
  text-indent: 20px;
  font-size: 14px;
  background: #fff !important;
}

.inp input.user {
  margin-bottom: 16px;
}

.inp .rember {
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
  margin-top: 10px;
}

.inp .rember p:first-of-type {
  font-size: 12px;
  color: #4a4a4a;
  letter-spacing: .19px;
  margin-left: 22px;
  display: -ms-flexbox;
  display: flex;
  -ms-flex-align: center;
  align-items: center;
  /*position: relative;*/
}

.inp .rember p:nth-of-type(2) {
  font-size: 14px;
  color: #9b9b9b;
  letter-spacing: .19px;
  cursor: pointer;
}

.inp .rember input {
  outline: 0;
  width: 30px;
  height: 45px;
  border-radius: 4px;
  border: 1px solid #d9d9d9;
  text-indent: 20px;
  font-size: 14px;
  background: #fff !important;
}

.inp .rember p span {
  display: inline-block;
  font-size: 12px;
  width: 100px;
  /*position: absolute;*/
  /*left: 20px;*/

}

#geetest {
  margin-top: 20px;
}

.login_btn {
  width: 100%;
  height: 45px;
  background: #396fcc;
  border-radius: 5px;
  font-size: 16px;
  color: #fff;
  letter-spacing: .26px;
  margin-top: 30px;
}

.inp .go_login {
  text-align: center;
  font-size: 14px;
  color: #9b9b9b;
  letter-spacing: .26px;
  padding-top: 20px;
}

.inp .go_login span {
  color: #84cc39;
  cursor: pointer;
}
</style>
```

### 路由守卫

完成了登录功能以后，我们要防止用户翻墙访问需要认证身份的页面时，可以基于vue-router的导航守卫来完成。

没有登陆状态，没有token的用户无法进入项目站点，`src/router/index.js`，代码：

```javascript
import {createRouter, createWebHistory} from 'vue-router'
import Login from '../views/Login.vue'
import Base from '../views/Base'
import ShowCenter from '../views/ShowCenter'
import Host from '../views/Host'
import storage from "@/utils/storage";

const routes = [
    {
        meta: {
            title: 'uric自动化运维平台'
        },
        path: '/autocve',
        alias: '/', // 给当前路径起一个别名
        name: 'Base',
        component: Base, // 快捷键：Alt+Enter快速导包,
        children: [
            {
                path: 'show_center',
                alias: '', // 给当前路径起一个别名
                name: 'ShowCenter',
                component: ShowCenter,
                meta: {
                    title: "展示中心",
                    authorization: true
                },
            },
            {
                path: 'host',
                name: 'Host',
                component: Host,
                meta: {
                    title: "主机管理",
                    authorization: true
                },
            },
        ],
    },
    {
        meta: {
            title: '账户登陆',
            authorization: false
        },
        path: '/login',
        name: 'Login',
        component: Login // 快捷键：Alt+Enter快速导包，
    },
]

const router = createRouter({
    history: createWebHistory(process.env.BASE_URL),
    routes
})


// 导航守卫
router.beforeEach((to, from, next) => {
    document.title = to.meta.title
    // 登录状态验证
    console.log("to meta", to.meta)
    if (to.meta.authorization && !storage.getUserInfo()) {
        next({"name": "Login"})
    } else {
        next()
    }
})

// 暴露路由对象
export default router
```

本地拿到token以后，我们发送任何需要登录之后才能发送的请求，都需要先对token的有效性进行认证，然后将token携带到请求头中，来通过后台接口的 token的校验。

### 客户端注销登陆

`src/views/Base.vue`，代码：

```js
import storage from '@/utils/storage.js'
...
const logout = () => {
  storage.clearStorage()
  router.push("/login")
}
```

# 
