
## SQL指令

- 连接指令：`mysql -u 用户名 -p 密码 -h host -P 端口`
### 数据库操作
```mysql
creat database [if not exists] 数据库名 [character set utf8]; -- 创建数据库

show databases; -- 查看所有数据库
show create database go10; -- 查看某一个数据库的创建信息

alter database db_name [character set xxx] --修改数据库字符集

drop database go10; -- 删除数据库

use 数据库名; -- 进入数据库
select database(); -- 查看当前使用的数据库

```

### 数据表操作

####  创建表结构
```mysql
create table table_name (
	字段1 类型 [约束], -- 注释
	字段2 类型 [约束]
)

create table user (
	name varchar(5) not null,
	age int default,
	birth date,
	salary decimal(8,2)   -- 999999.99
);
```

#### 查看表结构
```mysql
show tables; -- 查看所有表
show create table user; -- 查看某一张表的创建信息

desc user -- 查看某一张表的结构
drop table user; -- 删除表结构

-- 修改表结构
1. 添加一个字段
	1. alter table user add gender varchar(32) not null after age; -- 放在age后面
2. 删除一个字段
	1. alter table user drop gender
3. 修改字段类型
	1. alter table user modify gender int;
RENAME
CHANGE



select * from user-- 查看表记录
```
### 表记录操作

#### 添加记录
```mysql
1. 添加记录：insert ... values 语句
	1. insert 表名 () values ();
	2. insert 表名 (字段1,字段2,字段3) values (字段1的值,字段2的值,字段3的值);
	3. 批量插入
	insert 表名 (字段1,字段2,字段3) values (字段1的值,字段2的值,字段3的值),
										 (字段1的值,字段2的值,字段3的值),
										 (字段1的值,字段2的值,字段3的值),
										 (字段1的值,字段2的值,字段3的值);
```

#### 查询记录
```mysql
select * from 表名称; -- 效率很低 *要先找一下所有的字段
select name, city from emp;



```

##### Where语句
```mysql
/*
select 字段1，字段2，from 表名
	where 条件
*/

select * from emp where age>24;
select * from emp where age between 20 and 30;
select * from emp where salary in (600,1000,300000);
select * from emp where (age <25) and (salary>5000);

select * from emp where name like 'a%';  -- %代表多个字符 _代表一个字符
select * from emp where name REGEXP "^a.*?n"; -- 正则
```
##### order与limit语句
```mysql

-- order by
select * from emp order by age; -- 按照字段age排序
select * from emp order by age desc ; -- desc 降序 asc 升序
select * from emp order by age desc,salary asc; -- 先按照age降序排列，age一样的按照salary升序排列


-- limit 网页的分页操作
select * from emp where salary >2000;
select * from emp where salary > 2000 limit 3; -- 拿前3条
select * from emp where salary > 2000 limit 5,2; -- 略过前5条取两条

```

##### 分组语句Group by
```mysql
-- 每一个部门的平均薪资
select dep 
from emp 
group by dep; -- 分组之后不能用*查询

select dep,avg(salary),max(age) 
from emp 
group by dep; -- 分组后 组内的平均薪资avg ，最大年龄max，count数量,sum总和


-- 男女个数（按男女分组）
select gender, count(*)
from emp 
group by gender;


-- group_concat(name) ; 每个组名字拼接给我
select dep,group_concat(name) 
from emp 
group by dep;

-- distinct 去重
select distinct name,age* from emp;
```

##### Having语句
- Having用于分组后的条件过滤
- where用于分组前的条件过滤
```mysql
-- 平均薪资大于8000的部分
select dep ,avg(salary) as svg_salary
from emp
group by dep
having svg_salary >8000;
```

#### 更新记录
```mysql
-- 把年龄大于30的人薪资全部改成20000
update emp 
set salary=20000
where age>30;
```

#### 删除记录
```mysql
-- 把薪资大于20000 和年龄>29的全部删除
delete from emp
where salary=20000 or age>29;
```



### 表的关联关系

#### 建立关联关系的意义
1. 一对多：==在多的表中建立一个关联字段==
```bash
书籍管理系统

Book表

id titile   price
1  红与黑    199  
2  傲慢与偏见 299  

我还想存出版社和出版社地址，这样就会存很多重复的数据

Publish表
id publish  publish_addr publish_email
1  清华出版社  北京         xxx@qq.com
2  北大出版社  北京

一个出版社对应多本书 （多本书对应一个出版社）

一对多：在多的表中建立一个关联字段

Book表 (建立一个关联字段)

id titile   price publish_id
1  红与黑    199     2
2  傲慢与偏见 299     2


```
2. 多对多: ==创建关联表（id、 两个关联字段）==
```bash
Book表

id titile   price
1  红与黑    199  
2  傲慢与偏见 299  


Author表
id name age tel
1  yuan 23  110
2  rain 24  911

一本书可以有多个作者，一个作者也可以出版多本书
多对多: 创建关联表（id、 两个关联字段）

Book2Author关联表
id book_id author_id
1  1       1
2  1       2
3  2       3
```
3. 一对一: ==在任意表中建立关联字段，关联字段保证唯一性==
```bash
Author表
id name age tel
1  yuan 23  110
2  rain 24  911


Author还有hobby addr 但是不重要，我可以重新拆一个表存不重要的数据

Author表(关联字段)
id name age ad_id
1  yuan 23  1
2  rain 24  2

AuthorDetail表

id tel hobby gf   addr
1  110 girl  铁锤  北京
2  911 tea   钢蛋  山西
```
#### 一对多

```sql 
-- 书籍表
CREATE TABLE book(
id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(32),
price DOUBLE(5,2),    
pub_id INT NOT NULL
)ENGINE=INNODB CHARSET=utf8;


-- 出版社表
CREATE TABLE publisher(
id INT PRIMARY KEY AUTO_INCREMENT,
name VARCHAR(32),
email VARCHAR(32),
addr VARCHAR(32)
)ENGINE=INNODB CHARSET=utf8;

-- 插入数据
INSERT INTO book(title,price,pub_id) VALUES
('西游记',15,1),
('三国演义',45,2),
('红楼梦',66,3),
('水浒传',21,2),
('红与黑',67,3),
('乱世佳人',44,6),
('飘',56,1),
('放风筝的人',78,3);

INSERT INTO publisher(id,name,email,addr) VALUES
(1,'清华出版社',"123","bj"),
(2,'北大出版社',"234","bj"),
(3,'机械工业出版社',"345","nj"),
(4,'邮电出版社',"456","nj"),
(5,'电子工业出版社',"567","bj"),
(6,'人民大学出版社',"678","bj");
```

```sql 
mysql> select * from book;
+----+------------+-------+--------+
| id | title      | price | pub_id |
+----+------------+-------+--------+
|  1 | 西游记     | 15.00 |      1 |
|  2 | 三国演义   | 45.00 |      2 |
|  3 | 红楼梦     | 66.00 |      3 |
|  4 | 水浒传     | 21.00 |      2 |
|  5 | 红与黑     | 67.00 |      3 |
|  6 | 乱世佳人   | 44.00 |      6 |
|  7 | 飘         | 56.00 |      1 |
|  8 | 放风筝的人 | 78.00 |      3 |
+----+------------+-------+--------+
8 rows in set (0.00 sec)

mysql> select * from publisher;
+----+----------------+-------+------+
| id | name           | email | addr |
+----+----------------+-------+------+
|  1 | 清华出版社     | 123   | bj   |
|  2 | 北大出版社     | 234   | bj   |
|  3 | 机械工业出版社 | 345   | nj   |
|  4 | 邮电出版社     | 456   | nj   |
|  5 | 电子工业出版社 | 567   | bj   |
|  6 | 人民大学出版社 | 678   | bj   |
+----+----------------+-------+------+
6 rows in set (0.00 sec)
```

#### 多对多

```sql 
-- 作者表
CREATE TABLE author(
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(32) NOT NULL
)ENGINE=INNODB CHARSET=utf8;

-- 作者表和书籍表的多对多关系表
CREATE TABLE book2author(
id INT NOT NULL UNIQUE AUTO_INCREMENT,
author_id INT NOT NULL,
book_id INT NOT NULL
)ENGINE=INNODB CHARSET=utf8;

-- 插入数据

INSERT INTO author(NAME) VALUES
('yuan'),
('rain'),
('alvin'),
('eric');

-- 插入关系数据
INSERT INTO book2author(author_id,book_id) VALUES
(1,1),
(1,2),
(2,1),
(3,3),
(3,4),
(1,3);
```


#### 一对一

> 场景：
>
> 1. 一个系统必然有 Employee（员工表）（包含字段：EmployeeId、姓名、性别、年龄、电话、地址等），每个员工都为一个用户，所以还有张 User 表（包含字段：UserId（关联 EmployeeId）、用户名、密码、角色等），这样你会发现，整合为一张表是否不太妥当？因为，User 的记录只会在登录时用到，感觉有点违背三大范式中的“**确保每列都和主键列直接关联，而不是间接关联**”。
> 2. 还有种情况，这就要根据具体的业务来决定了。如果，当一张表的字段过于太多，而很多字段可能只有在某些情况下，才会使用到，这时也可以考虑使用一对一设计。

在我们这个例子中，比如，作者表可以有一张一对一的作者详细信息表。

````sql 
CREATE TABLE authorDetail(
id INT PRIMARY KEY AUTO_INCREMENT,
tel VARCHAR(32),
addr VARCHAR(32),
author_id INT NOT NULL unique -- 也可以给author添加一个关联字段：   alter table author add authorDetail_id INT NOT NULL
)ENGINE=INNODB CHARSET=utf8;

-- 插入数据
INSERT INTO authorDetail(tel,addr,author_id) VALUES
("110","北京",1),
("911","成都",2),
("119","上海",3),
("111","广州",4);

````

> 区别于一对多，关联字段加唯一约束！ 


### 关联查询


#### 一对多关联查询
##### 子查询

子查询是 MySQL 中比较常用的查询方法，通过子查询可以实现多表关联查询。子查询指将一个查询语句嵌套在另一个查询语句中。
```sql 
-- 查询乱世佳人的出版社名称
 select pub_id from book where title="乱世佳人";
 select name from publisher where id = 6;

-- 查询清华出版社出版所有书籍名称
select id from publisher where name="清华出版社";
select id,title from book where pub_id = 1;

-- 查询西游记的作者名字
select id from book where title="西游记";
select author_id from book2author where book_id=1;
select name from author where id in (1,2);
```


##### 笛卡尔积
```mysql
select * from book,publisher where book.pub_id = publisher.id
```

##### Inner Join语句
> 
```mysql
select * from book
	inner join publisher on book.pub_id =publisher.id
	where book.title="三国演义"
```


#### 多对多关联查询
1. `inner join`: 连接表中连接字段为空的无法显示(如果书没有对应的作者 则就显示不出来了)
```mysql
-- 出版西游记的作者名字
select author.name 
from book 
	inner join book2author on book.id = book2author.book_id   -- book 和book2author拼接起来
	inner join author on author.id = book2author.author_id -- 将author 也拼接进去
	where book.title="西游记"


-- 查询每一本书的作者的个数 且 作者个数>1    //每 -- 分组
select book.title,count(*) as author_count
from book
	inner join book2author on book.id = book2author.book_id   -- book 和book2author拼接起来
	inner join author on author.id = book2author.author_id -- 将author 也拼接进去
	group by book.title
	having author_count>1


```
2. `left join`：以左边的表为主，如果没有匹配成功，则以左边的表为主，补充null
```mysql
-- 查询每一本书的作者的个数    //每 -- 分组
select book.title,count(author.NAME) as author_count  -- 这里count如果用*,即使这个书没有记录也会被查询为1，因为count(*)关心这个记录的出现的次数
from book
	left join book2author on book.id = book2author.book_id   -- book 和book2author拼接起来
	left join author on author.id = book2author.author_id -- 将author 也拼接进去
	group by book.title
```


### 外键约束

